[{"content":"","date":"2022-03-06T00:00:00Z","image":"https://rmondjone.github.io/posts/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://rmondjone.github.io/posts/hello-world/","title":"Hello"},{"content":"一、插件下载 JsonToTypeScript插件是一款Json快速转TS实体插件，可以直接在WebStorm应用市场上搜索JsonToTypeScript即可下载。 二、插件的使用方法 使用快捷键Alt+T或者使用Generate菜单\n直接在ts、js文件中使用Alt+T快捷键或者Generate快捷键，调起生成弹窗。在弹窗中输入你想要转换的JSON字符串即可，当然你也可以点击格式化按钮进行一次格式化。\n","date":"2023-04-08T14:57:49+08:00","permalink":"https://rmondjone.github.io/posts/jetbrains/jsontotypescript/","title":"JsonToTypeScript插件使用介绍"},{"content":"前言 由于网上大部分自定义相机的实现，都是耦合性比较强的，不方便今后的复用，所以我自己实现了一套自定义相机，方便以后的扩展。自定义相机分为以下3个部分。\n相机的预览布局SurfaceView ，方便用户实时预览。写成自定义控件，方便今后的复用。 相机的自动聚焦以及点触聚焦，拍照需要聚焦，要不然拍出的图片很可能是模糊的。写成自定义控件，方便今后的复用。 相机的自定义布局，这部分随着需求的迭代变换，前面的2大块不需要改动。 一、预览布局的实现 （1） 抽离预览图层为一个单独的自定义控件CameraPreview ，传递Camre对象，设置必要的相机预览参数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 package com.focustech.xyz.baselibrary.camera; import android.app.Activity; import android.content.Context; import android.graphics.ImageFormat; import android.hardware.Camera; import android.view.SurfaceHolder; import android.view.SurfaceView; import com.focustech.xyz.baselibrary.common.XyzLogger; import java.io.IOException; import java.util.SortedSet; /** * @author 郭翰林 * @date 2019/2/28 0028 17:06 * 注释:相机预览视图 */ public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback { private SurfaceHolder mHolder; private Camera mCamera; private boolean isPreview; private Context context; /** * 预览尺寸集合 */ private final SizeMap mPreviewSizes = new SizeMap(); /** * 图片尺寸集合 */ private final SizeMap mPictureSizes = new SizeMap(); /** * 屏幕旋转显示角度 */ private int mDisplayOrientation; /** * 设备屏宽比 */ private AspectRatio mAspectRatio; /** * 注释：构造函数 * 时间：2019/2/28 0028 17:10 * 作者：郭翰林 * * @param context * @param mCamera */ public CameraPreview(Context context, Camera mCamera) { super(context); this.context = context; this.mCamera = mCamera; this.mHolder = getHolder(); this.mHolder.addCallback(this); mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); mDisplayOrientation = ((Activity) context).getWindowManager().getDefaultDisplay().getRotation(); mAspectRatio = AspectRatio.of(16, 9); } @Override public void surfaceCreated(SurfaceHolder holder) { try { //设置设备高宽比 mAspectRatio = getDeviceAspectRatio((Activity) context); //设置预览方向 mCamera.setDisplayOrientation(90); Camera.Parameters parameters = mCamera.getParameters(); //获取所有支持的预览尺寸 mPreviewSizes.clear(); for (Camera.Size size : parameters.getSupportedPreviewSizes()) { mPreviewSizes.add(new Size(size.width, size.height)); } //获取所有支持的图片尺寸 mPictureSizes.clear(); for (Camera.Size size : parameters.getSupportedPictureSizes()) { mPictureSizes.add(new Size(size.width, size.height)); } Size previewSize = chooseOptimalSize(mPreviewSizes.sizes(mAspectRatio)); Size pictureSize = mPictureSizes.sizes(mAspectRatio).last(); //设置相机参数 parameters.setPreviewSize(previewSize.getWidth(), previewSize.getHeight()); parameters.setPictureSize(pictureSize.getWidth(), pictureSize.getHeight()); parameters.setPictureFormat(ImageFormat.JPEG); parameters.setRotation(90); mCamera.setParameters(parameters); //把这个预览效果展示在SurfaceView上面 mCamera.setPreviewDisplay(holder); //开启预览效果 mCamera.startPreview(); isPreview = true; } catch (IOException e) { XyzLogger.e(\u0026#34;CameraPreview\u0026#34;, \u0026#34;相机预览错误: \u0026#34; + e.getMessage()); } } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { if (holder.getSurface() == null) { return; } //停止预览效果 mCamera.stopPreview(); //重新设置预览效果 try { mCamera.setPreviewDisplay(mHolder); } catch (IOException e) { e.printStackTrace(); } mCamera.startPreview(); } @Override public void surfaceDestroyed(SurfaceHolder holder) { if (mCamera != null) { if (isPreview) { //正在预览 mCamera.stopPreview(); mCamera.release(); } } } /** * 注释：获取设备屏宽比 * 时间：2019/3/4 0004 12:55 * 作者：郭翰林 */ private AspectRatio getDeviceAspectRatio(Activity activity) { int width = activity.getWindow().getDecorView().getWidth(); int height = activity.getWindow().getDecorView().getHeight(); return AspectRatio.of(height, width); } /** * 注释：选择合适的预览尺寸 * 时间：2019/3/4 0004 11:25 * 作者：郭翰林 * * @param sizes * @return */ @SuppressWarnings(\u0026#34;SuspiciousNameCombination\u0026#34;) private Size chooseOptimalSize(SortedSet\u0026lt;Size\u0026gt; sizes) { int desiredWidth; int desiredHeight; final int surfaceWidth = getWidth(); final int surfaceHeight = getHeight(); if (isLandscape(mDisplayOrientation)) { desiredWidth = surfaceHeight; desiredHeight = surfaceWidth; } else { desiredWidth = surfaceWidth; desiredHeight = surfaceHeight; } Size result = null; for (Size size : sizes) { if (desiredWidth \u0026lt;= size.getWidth() \u0026amp;\u0026amp; desiredHeight \u0026lt;= size.getHeight()) { return size; } result = size; } return result; } /** * Test if the supplied orientation is in landscape. * * @param orientationDegrees Orientation in degrees (0,90,180,270) * @return True if in landscape, false if portrait */ private boolean isLandscape(int orientationDegrees) { return (orientationDegrees == 90 || orientationDegrees == 270); } } 这里有2处地方需要注意，相机要设置正确的预览尺寸和正确的图片的尺寸。如果预览尺寸设置错误，则预览布局会被拉伸或者收缩。如果图片尺寸设置错误，部分机型会导致闪退或者拍出的照片很不清晰。\n这里适配预览尺寸和图片尺寸，是根据设备的屏宽比和Carme拿到的说支持的预览尺寸和图片尺寸计算得出应有的预览尺寸和图片尺寸，代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //设置设备高宽比 mAspectRatio = getDeviceAspectRatio((Activity) context);. Camera.Parameters parameters = mCamera.getParameters(); //获取所有支持的预览尺寸 mPreviewSizes.clear(); for (Camera.Size size : parameters.getSupportedPreviewSizes()) { mPreviewSizes.add(new Size(size.width, size.height)); } //获取所有支持的图片尺寸 mPictureSizes.clear(); for (Camera.Size size : parameters.getSupportedPictureSizes()) { mPictureSizes.add(new Size(size.width, size.height)); } Size previewSize = chooseOptimalSize(mPreviewSizes.sizes(mAspectRatio)); Size pictureSize = mPictureSizes.sizes(mAspectRatio).last(); //设置相机参数 parameters.setPreviewSize(previewSize.getWidth(), previewSize.getHeight()); parameters.setPictureSize(pictureSize.getWidth(), pictureSize.getHeight()); 1 2 3 4 5 6 7 8 9 10 /** * 注释：获取设备屏宽比 * 时间：2019/3/4 0004 12:55 * 作者：郭翰林 */ private AspectRatio getDeviceAspectRatio(Activity activity) { int width = activity.getWindow().getDecorView().getWidth(); int height = activity.getWindow().getDecorView().getHeight(); return AspectRatio.of(height, width); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 注释：选择合适的预览尺寸 * 时间：2019/3/4 0004 11:25 * 作者：郭翰林 * * @param sizes * @return */ @SuppressWarnings(\u0026#34;SuspiciousNameCombination\u0026#34;) private Size chooseOptimalSize(SortedSet\u0026lt;Size\u0026gt; sizes) { int desiredWidth; int desiredHeight; final int surfaceWidth = getWidth(); final int surfaceHeight = getHeight(); if (isLandscape(mDisplayOrientation)) { desiredWidth = surfaceHeight; desiredHeight = surfaceWidth; } else { desiredWidth = surfaceWidth; desiredHeight = surfaceHeight; } Size result = null; for (Size size : sizes) { if (desiredWidth \u0026lt;= size.getWidth() \u0026amp;\u0026amp; desiredHeight \u0026lt;= size.getHeight()) { return size; } result = size; } return result; } （2）屏宽比AspectRatio的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 package com.focustech.xyz.baselibrary.camera; import android.os.Parcel; import android.os.Parcelable; import android.support.annotation.NonNull; import android.support.v4.util.SparseArrayCompat; /** * @author 郭翰林 * @date 2019/3/4 0004 11:11 * 注释:屏宽比 */ public class AspectRatio implements Comparable\u0026lt;AspectRatio\u0026gt;, Parcelable { private final static SparseArrayCompat\u0026lt;SparseArrayCompat\u0026lt;AspectRatio\u0026gt;\u0026gt; sCache = new SparseArrayCompat\u0026lt;\u0026gt;(16); private final int mX; private final int mY; /** * Returns an instance of {@link AspectRatio} specified by {@code x} and {@code y} values. * The values {@code x} and {@code} will be reduced by their greatest common divider. * * @param x The width * @param y The height * @return An instance of {@link AspectRatio} */ public static AspectRatio of(int x, int y) { int gcd = gcd(x, y); x /= gcd; y /= gcd; SparseArrayCompat\u0026lt;AspectRatio\u0026gt; arrayX = sCache.get(x); if (arrayX == null) { AspectRatio ratio = new AspectRatio(x, y); arrayX = new SparseArrayCompat\u0026lt;\u0026gt;(); arrayX.put(y, ratio); sCache.put(x, arrayX); return ratio; } else { AspectRatio ratio = arrayX.get(y); if (ratio == null) { ratio = new AspectRatio(x, y); arrayX.put(y, ratio); } return ratio; } } /** * Parse an {@link AspectRatio} from a {@link String} formatted like \u0026#34;4:3\u0026#34;. * * @param s The string representation of the aspect ratio * @return The aspect ratio * @throws IllegalArgumentException when the format is incorrect. */ public static AspectRatio parse(String s) { int position = s.indexOf(\u0026#39;:\u0026#39;); if (position == -1) { throw new IllegalArgumentException(\u0026#34;Malformed aspect ratio: \u0026#34; + s); } try { int x = Integer.parseInt(s.substring(0, position)); int y = Integer.parseInt(s.substring(position + 1)); return AspectRatio.of(x, y); } catch (NumberFormatException e) { throw new IllegalArgumentException(\u0026#34;Malformed aspect ratio: \u0026#34; + s, e); } } private AspectRatio(int x, int y) { mX = x; mY = y; } public int getX() { return mX; } public int getY() { return mY; } public boolean matches(Size size) { int gcd = gcd(size.getWidth(), size.getHeight()); int x = size.getWidth() / gcd; int y = size.getHeight() / gcd; return mX == x \u0026amp;\u0026amp; mY == y; } @Override public boolean equals(Object o) { if (o == null) { return false; } if (this == o) { return true; } if (o instanceof AspectRatio) { AspectRatio ratio = (AspectRatio) o; return mX == ratio.mX \u0026amp;\u0026amp; mY == ratio.mY; } return false; } @Override public String toString() { return mX + \u0026#34;:\u0026#34; + mY; } public float toFloat() { return (float) mX / mY; } @Override public int hashCode() { // assuming most sizes are \u0026lt;2^16, doing a rotate will give us perfect hashing return mY ^ ((mX \u0026lt;\u0026lt; (Integer.SIZE / 2)) | (mX \u0026gt;\u0026gt;\u0026gt; (Integer.SIZE / 2))); } @Override public int compareTo(@NonNull AspectRatio another) { if (equals(another)) { return 0; } else if (toFloat() - another.toFloat() \u0026gt; 0) { return 1; } return -1; } /** * @return The inverse of this {@link AspectRatio}. */ public AspectRatio inverse() { //noinspection SuspiciousNameCombination return AspectRatio.of(mY, mX); } private static int gcd(int a, int b) { while (b != 0) { int c = b; b = a % b; a = c; } return a; } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(mX); dest.writeInt(mY); } public static final Parcelable.Creator\u0026lt;AspectRatio\u0026gt; CREATOR = new Parcelable.Creator\u0026lt;AspectRatio\u0026gt;() { @Override public AspectRatio createFromParcel(Parcel source) { int x = source.readInt(); int y = source.readInt(); return AspectRatio.of(x, y); } @Override public AspectRatio[] newArray(int size) { return new AspectRatio[size]; } }; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.focustech.xyz.baselibrary.camera; import android.support.annotation.NonNull; /** * 注释：尺寸对象 * 时间：2019/3/4 0004 11:14 * 作者：郭翰林 */ public class Size implements Comparable\u0026lt;Size\u0026gt; { private final int mWidth; private final int mHeight; /** * Create a new immutable Size instance. * * @param width The width of the size, in pixels * @param height The height of the size, in pixels */ public Size(int width, int height) { mWidth = width; mHeight = height; } public int getWidth() { return mWidth; } public int getHeight() { return mHeight; } @Override public boolean equals(Object o) { if (o == null) { return false; } if (this == o) { return true; } if (o instanceof Size) { Size size = (Size) o; return mWidth == size.mWidth \u0026amp;\u0026amp; mHeight == size.mHeight; } return false; } @Override public String toString() { return mWidth + \u0026#34;x\u0026#34; + mHeight; } @Override public int hashCode() { // assuming most sizes are \u0026lt;2^16, doing a rotate will give us perfect hashing return mHeight ^ ((mWidth \u0026lt;\u0026lt; (Integer.SIZE / 2)) | (mWidth \u0026gt;\u0026gt;\u0026gt; (Integer.SIZE / 2))); } @Override public int compareTo(@NonNull Size another) { return mWidth * mHeight - another.mWidth * another.mHeight; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package com.focustech.xyz.baselibrary.camera; import android.support.v4.util.ArrayMap; import java.util.Set; import java.util.SortedSet; import java.util.TreeSet; /** * @author 郭翰林 * @date 2019/3/4 0004 11:13 * 注释:尺寸集合 */ public class SizeMap { private final ArrayMap\u0026lt;AspectRatio, SortedSet\u0026lt;Size\u0026gt;\u0026gt; mRatios = new ArrayMap\u0026lt;\u0026gt;(); /** * Add a new {@link Size} to this collection. * * @param size The size to add. * @return {@code true} if it is added, {@code false} if it already exists and is not added. */ public boolean add(Size size) { for (AspectRatio ratio : mRatios.keySet()) { if (ratio.matches(size)) { final SortedSet\u0026lt;Size\u0026gt; sizes = mRatios.get(ratio); if (sizes.contains(size)) { return false; } else { sizes.add(size); return true; } } } // None of the existing ratio matches the provided size; add a new key SortedSet\u0026lt;Size\u0026gt; sizes = new TreeSet\u0026lt;\u0026gt;(); sizes.add(size); mRatios.put(AspectRatio.of(size.getWidth(), size.getHeight()), sizes); return true; } /** * Removes the specified aspect ratio and all sizes associated with it. * * @param ratio The aspect ratio to be removed. */ public void remove(AspectRatio ratio) { mRatios.remove(ratio); } Set\u0026lt;AspectRatio\u0026gt; ratios() { return mRatios.keySet(); } SortedSet\u0026lt;Size\u0026gt; sizes(AspectRatio ratio) { return mRatios.get(ratio); } void clear() { mRatios.clear(); } boolean isEmpty() { return mRatios.isEmpty(); } } 二、相机点触自动聚焦并绘制对焦框的实现 （1）抽离聚焦框为单独的自定义组件，传递Carma对象和聚焦回调，设置必要的相机参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 package com.focustech.xyz.baselibrary.camera; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.Rect; import android.hardware.Camera; import android.support.v7.widget.AppCompatImageView; import android.util.AttributeSet; import android.view.WindowManager; import com.focustech.xyz.baselibrary.common.XyzLogger; import java.util.ArrayList; import java.util.List; /** * @author 郭翰林 * @date 2019/3/1 0001 9:21 * 注释:对焦框 */ public class OverCameraView extends AppCompatImageView { private Context context; //焦点附近设置矩形区域作为对焦区域 private Rect touchFocusRect; private Paint touchFocusPaint; //是否正在对焦 private boolean isFoucuing; public OverCameraView(Context context) { this(context, null, 0); } public OverCameraView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public OverCameraView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context); } private void init(Context context) { this.context = context; //画笔设置 touchFocusPaint = new Paint(); touchFocusPaint.setColor(Color.GREEN); touchFocusPaint.setStyle(Paint.Style.STROKE); touchFocusPaint.setStrokeWidth(3); } public boolean isFoucuing() { return isFoucuing; } public void setFoucuing(boolean foucuing) { isFoucuing = foucuing; } /** * 注释：对焦并绘制对焦矩形框 * 时间：2019/3/1 0001 9:28 * 作者：郭翰林 * * @param camera * @param autoFocusCallback * @param x * @param y */ public void setTouchFoucusRect(Camera camera, Camera.AutoFocusCallback autoFocusCallback, float x, float y) { //以焦点为中心，宽度为200的矩形框 touchFocusRect = new Rect((int) (x - 100), (int) (y - 100), (int) (x + 100), (int) (y + 100)); //对焦光感区域 int left = touchFocusRect.left * 2000 / getWindowWidth(context) - 1000; int top = touchFocusRect.top * 2000 / getWindowHeight(context) - 1000; int right = touchFocusRect.right * 2000 / getWindowWidth(context) - 1000; int bottom = touchFocusRect.bottom * 2000 / getWindowHeight(context) - 1000; // 如果超出了(-1000,1000)到(1000, 1000)的范围，则会导致相机崩溃 left = left \u0026lt; -1000 ? -1000 : left; top = top \u0026lt; -1000 ? -1000 : top; right = right \u0026gt; 1000 ? 1000 : right; bottom = bottom \u0026gt; 1000 ? 1000 : bottom; final Rect targetFocusRect = new Rect(left, top, right, bottom); //对焦 doTouchFocus(camera, autoFocusCallback, targetFocusRect); //刷新界面，调用onDraw(Canvas canvas)函数绘制矩形框 postInvalidate(); } /** * 注释：设置camera参数，并完成对焦 * 时间：2019/3/1 0001 9:27 * 作者：郭翰林 * * @param camera * @param autoFocusCallback * @param tfocusRect */ public void doTouchFocus(Camera camera, Camera.AutoFocusCallback autoFocusCallback, final Rect tfocusRect) { if (camera == null || isFoucuing) { return; } try { final List\u0026lt;Camera.Area\u0026gt; focusList = new ArrayList\u0026lt;\u0026gt;(); Camera.Area focusArea = new Camera.Area(tfocusRect, 1000); focusList.add(focusArea); Camera.Parameters para = camera.getParameters(); para.setFocusAreas(focusList); para.setMeteringAreas(focusList); para.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO); camera.cancelAutoFocus(); camera.setParameters(para); camera.autoFocus(autoFocusCallback); isFoucuing = true; } catch (Exception e) { XyzLogger.e(\u0026#34;设置相机参数异常\u0026#34;, e.getMessage()); } } /** * 注释：对焦完成后，清除对焦矩形框 * 时间：2019/3/1 0001 9:28 * 作者：郭翰林 */ public void disDrawTouchFocusRect() { //将对焦区域设置为null，刷新界面后对焦框消失 touchFocusRect = null; //刷新界面，调用onDraw(Canvas canvas)函数 postInvalidate(); } @Override protected void onDraw(Canvas canvas) { //在画布上绘图，postInvalidate()后自动调用 drawTouchFocusRect(canvas); super.onDraw(canvas); } /** * 获取屏幕高度 */ @SuppressWarnings(\u0026#34;deprecation\u0026#34;) public static int getWindowHeight(Context cxt) { WindowManager wm = (WindowManager) cxt .getSystemService(Context.WINDOW_SERVICE); return wm.getDefaultDisplay().getHeight(); } /** * 获取屏幕宽度 */ @SuppressWarnings(\u0026#34;deprecation\u0026#34;) public static int getWindowWidth(Context cxt) { WindowManager wm = (WindowManager) cxt .getSystemService(Context.WINDOW_SERVICE); return wm.getDefaultDisplay().getWidth(); } private void drawTouchFocusRect(Canvas canvas) { if (null != touchFocusRect) { //根据对焦区域targetFocusRect，绘制自己想要的对焦框样式，本文在矩形四个角取L形状 //左下角 canvas.drawRect(touchFocusRect.left - 2, touchFocusRect.bottom, touchFocusRect.left + 20, touchFocusRect.bottom + 2, touchFocusPaint); canvas.drawRect(touchFocusRect.left - 2, touchFocusRect.bottom - 20, touchFocusRect.left, touchFocusRect.bottom, touchFocusPaint); //左上角 canvas.drawRect(touchFocusRect.left - 2, touchFocusRect.top - 2, touchFocusRect.left + 20, touchFocusRect.top, touchFocusPaint); canvas.drawRect(touchFocusRect.left - 2, touchFocusRect.top, touchFocusRect.left, touchFocusRect.top + 20, touchFocusPaint); //右上角 canvas.drawRect(touchFocusRect.right - 20, touchFocusRect.top - 2, touchFocusRect.right + 2, touchFocusRect.top, touchFocusPaint); canvas.drawRect(touchFocusRect.right, touchFocusRect.top, touchFocusRect.right + 2, touchFocusRect.top + 20, touchFocusPaint); //右下角 canvas.drawRect(touchFocusRect.right - 20, touchFocusRect.bottom, touchFocusRect.right + 2, touchFocusRect.bottom + 2, touchFocusPaint); canvas.drawRect(touchFocusRect.right, touchFocusRect.bottom - 20, touchFocusRect.right + 2, touchFocusRect.bottom, touchFocusPaint); } } } （2）在Activity中的onTouchEvent函数中触发相机聚焦 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_DOWN) { if (!isFoucing) { float x = event.getX(); float y = event.getY(); isFoucing = true; if (mCamera != null \u0026amp;\u0026amp; !isTakePhoto) { mOverCameraView.setTouchFoucusRect(mCamera, autoFocusCallback, x, y); } mRunnable = () -\u0026gt; { ToastUtil.showToast(this, \u0026#34;自动聚焦超时,请调整合适的位置拍摄！\u0026#34;); isFoucing = false; mOverCameraView.setFoucuing(false); mOverCameraView.disDrawTouchFocusRect(); }; //设置聚焦超时 mHandler.postDelayed(mRunnable, 3000); } } return super.onTouchEvent(event); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 注释：自动对焦回调 * 时间：2019/3/1 0001 10:02 * 作者：郭翰林 */ private Camera.AutoFocusCallback autoFocusCallback = new Camera.AutoFocusCallback() { @Override public void onAutoFocus(boolean success, Camera camera) { isFoucing = false; mOverCameraView.setFoucuing(false); mOverCameraView.disDrawTouchFocusRect(); //停止聚焦超时回调 mHandler.removeCallbacks(mRunnable); } }; 三、自定义相机布局 （1）自定义相机预览 （2）自定义相机实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 package com.focustech.xyz.baselibrary.camera; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.hardware.Camera; import android.os.Bundle; import android.os.Environment; import android.os.Handler; import android.support.annotation.Nullable; import android.support.v7.app.AppCompatActivity; import android.view.MotionEvent; import android.view.View; import android.widget.Button; import android.widget.FrameLayout; import android.widget.ImageView; import android.widget.RelativeLayout; import com.bumptech.glide.Glide; import com.focustech.xyz.baselibrary.R; import com.focustech.xyz.baselibrary.utils.PermissionUtils; import com.focustech.xyz.baselibrary.utils.ToastUtil; import com.newland.springdialog.AnimSpring; import com.yanzhenjie.permission.AndPermission; import com.yanzhenjie.permission.Permission; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; /** * @author 郭翰林 * @date 2019/2/28 0028 16:23 * 注释:Android自定义相机 */ public class CameraActivity extends AppCompatActivity implements View.OnClickListener { public static final String KEY_IMAGE_PATH = \u0026#34;imagePath\u0026#34;; /** * 相机预览 */ private FrameLayout mPreviewLayout; /** * 拍摄按钮视图 */ private RelativeLayout mPhotoLayout; /** * 确定按钮视图 */ private RelativeLayout mConfirmLayout; /** * 闪光灯 */ private ImageView mFlashButton; /** * 拍照按钮 */ private ImageView mPhotoButton; /** * 取消保存按钮 */ private ImageView mCancleSaveButton; /** * 保存按钮 */ private ImageView mSaveButton; /** * 聚焦视图 */ private OverCameraView mOverCameraView; /** * 相机类 */ private Camera mCamera; /** * Handle */ private Handler mHandler = new Handler(); private Runnable mRunnable; /** * 取消按钮 */ private Button mCancleButton; /** * 是否开启闪光灯 */ private boolean isFlashing; /** * 图片流暂存 */ private byte[] imageData; /** * 拍照标记 */ private boolean isTakePhoto; /** * 是否正在聚焦 */ private boolean isFoucing; /** * 蒙版类型 */ private MongolianLayerType mMongolianLayerType; /** * 蒙版图片 */ private ImageView mMaskImage; /** * 护照出入境蒙版 */ private ImageView mPassportEntryAndExitImage; /** * 提示文案容器 */ private RelativeLayout rlCameraTip; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_camre_layout); mMongolianLayerType = (MongolianLayerType) getIntent().getSerializableExtra(\u0026#34;MongolianLayerType\u0026#34;); PermissionUtils.applicationPermissions(this, new PermissionUtils.PermissionListener() { @Override public void onSuccess(Context context) { initView(); setOnclickListener(); } @Override public void onFailed(Context context) { if (AndPermission.hasAlwaysDeniedPermission(context, Permission.Group.CAMERA) \u0026amp;\u0026amp; AndPermission.hasAlwaysDeniedPermission(context, Permission.Group.STORAGE)) { AndPermission.with(context).runtime().setting().start(); } ToastUtil.showToast(context, context.getString(com.focustech.xyz.baselibrary.R.string.permission_camra_storage)); finish(); } }, Permission.Group.STORAGE, Permission.Group.CAMERA); } /** * 启动拍照界面 * * @param activity * @param requestCode * @param type */ public static void startMe(Activity activity, int requestCode, MongolianLayerType type) { Intent intent = new Intent(activity, CameraActivity.class); intent.putExtra(\u0026#34;MongolianLayerType\u0026#34;, type); activity.startActivityForResult(intent, requestCode); } /** * 注释：获取蒙版图片 * 时间：2019/3/4 0004 17:19 * 作者：郭翰林 * * @return */ private int getMaskImage() { if (mMongolianLayerType == MongolianLayerType.BANK_CARD) { return R.mipmap.bank_card; } else if (mMongolianLayerType == MongolianLayerType.HK_MACAO_TAIWAN_PASSES_POSITIVE) { return R.mipmap.hk_macao_taiwan_passes_positive; } else if (mMongolianLayerType == MongolianLayerType.HK_MACAO_TAIWAN_PASSES_NEGATIVE) { return R.mipmap.hk_macao_taiwan_passes_negative; } else if (mMongolianLayerType == MongolianLayerType.IDCARD_POSITIVE) { return R.mipmap.idcard_positive; } else if (mMongolianLayerType == MongolianLayerType.IDCARD_NEGATIVE) { return R.mipmap.idcard_negative; } else if (mMongolianLayerType == MongolianLayerType.PASSPORT_PERSON_INFO) { return R.mipmap.passport_person_info; } return 0; } /** * 注释：设置监听事件 * 时间：2019/3/1 0001 11:13 * 作者：郭翰林 */ private void setOnclickListener() { mCancleButton.setOnClickListener(this); mCancleSaveButton.setOnClickListener(this); mFlashButton.setOnClickListener(this); mPhotoButton.setOnClickListener(this); mSaveButton.setOnClickListener(this); } @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_DOWN) { if (!isFoucing) { float x = event.getX(); float y = event.getY(); isFoucing = true; if (mCamera != null \u0026amp;\u0026amp; !isTakePhoto) { mOverCameraView.setTouchFoucusRect(mCamera, autoFocusCallback, x, y); } mRunnable = () -\u0026gt; { ToastUtil.showToast(this, \u0026#34;自动聚焦超时,请调整合适的位置拍摄！\u0026#34;); isFoucing = false; mOverCameraView.setFoucuing(false); mOverCameraView.disDrawTouchFocusRect(); }; //设置聚焦超时 mHandler.postDelayed(mRunnable, 3000); } } return super.onTouchEvent(event); } /** * 注释：自动对焦回调 * 时间：2019/3/1 0001 10:02 * 作者：郭翰林 */ private Camera.AutoFocusCallback autoFocusCallback = new Camera.AutoFocusCallback() { @Override public void onAutoFocus(boolean success, Camera camera) { isFoucing = false; mOverCameraView.setFoucuing(false); mOverCameraView.disDrawTouchFocusRect(); //停止聚焦超时回调 mHandler.removeCallbacks(mRunnable); } }; /** * 注释：拍照并保存图片到相册 * 时间：2019/3/1 0001 15:37 * 作者：郭翰林 */ private void takePhoto() { isTakePhoto = true; //调用相机拍照 mCamera.takePicture(null, null, null, (data, camera1) -\u0026gt; { //视图动画 mPhotoLayout.setVisibility(View.GONE); mConfirmLayout.setVisibility(View.VISIBLE); AnimSpring.getInstance(mConfirmLayout).startRotateAnim(120, 360); imageData = data; //停止预览 mCamera.stopPreview(); }); } /** * 注释：切换闪光灯 * 时间：2019/3/1 0001 15:40 * 作者：郭翰林 */ private void switchFlash() { isFlashing = !isFlashing; mFlashButton.setImageResource(isFlashing ? R.mipmap.flash_open : R.mipmap.flash_close); AnimSpring.getInstance(mFlashButton).startRotateAnim(120, 360); try { Camera.Parameters parameters = mCamera.getParameters(); parameters.setFlashMode(isFlashing ? Camera.Parameters.FLASH_MODE_TORCH : Camera.Parameters.FLASH_MODE_OFF); mCamera.setParameters(parameters); } catch (Exception e) { ToastUtil.showToast(this, \u0026#34;该设备不支持闪光灯\u0026#34;); } } /** * 注释：取消保存 * 时间：2019/3/1 0001 16:31 * 作者：郭翰林 */ private void cancleSavePhoto() { mPhotoLayout.setVisibility(View.VISIBLE); mConfirmLayout.setVisibility(View.GONE); AnimSpring.getInstance(mPhotoLayout).startRotateAnim(120, 360); //开始预览 mCamera.startPreview(); imageData = null; isTakePhoto = false; } /** * 解析拍出照片的路径 * * @param data * @return */ public static String parseResult(Intent data) { return data.getStringExtra(KEY_IMAGE_PATH); } @Override public void onClick(View v) { int id = v.getId(); if (id == R.id.cancle_button) { finish(); } else if (id == R.id.take_photo_button) { if (!isTakePhoto) { takePhoto(); } } else if (id == R.id.flash_button) { switchFlash(); } else if (id == R.id.save_button) { savePhoto(); } else if (id == R.id.cancle_save_button) { cancleSavePhoto(); } } /** * 注释：蒙版类型 * 时间：2019/2/28 0028 16:26 * 作者：郭翰林 */ public enum MongolianLayerType { /** * 护照个人信息 */ PASSPORT_PERSON_INFO, /** * 护照出入境 */ PASSPORT_ENTRY_AND_EXIT, /** * 身份证正面 */ IDCARD_POSITIVE, /** * 身份证反面 */ IDCARD_NEGATIVE, /** * 港澳通行证正面 */ HK_MACAO_TAIWAN_PASSES_POSITIVE, /** * 港澳通行证反面 */ HK_MACAO_TAIWAN_PASSES_NEGATIVE, /** * 银行卡 */ BANK_CARD } /** * 注释：初始化视图 * 时间：2019/3/1 0001 11:12 * 作者：郭翰林 */ private void initView() { mCancleButton = findViewById(R.id.cancle_button); mPreviewLayout = findViewById(R.id.camera_preview_layout); mPhotoLayout = findViewById(R.id.ll_photo_layout); mConfirmLayout = findViewById(R.id.ll_confirm_layout); mPhotoButton = findViewById(R.id.take_photo_button); mCancleSaveButton = findViewById(R.id.cancle_save_button); mSaveButton = findViewById(R.id.save_button); mFlashButton = findViewById(R.id.flash_button); mMaskImage = findViewById(R.id.mask_img); rlCameraTip = findViewById(R.id.camera_tip); mPassportEntryAndExitImage = findViewById(R.id.passport_entry_and_exit_img); mCamera = Camera.open(); CameraPreview preview = new CameraPreview(this, mCamera); mOverCameraView = new OverCameraView(this); mPreviewLayout.addView(preview); mPreviewLayout.addView(mOverCameraView); if (mMongolianLayerType == null) { mMaskImage.setVisibility(View.GONE); rlCameraTip.setVisibility(View.GONE); return; } //设置蒙版,护照出入境蒙版特殊处理 if (mMongolianLayerType != MongolianLayerType.PASSPORT_ENTRY_AND_EXIT) { Glide.with(this).load(getMaskImage()).into(mMaskImage); } else { mMaskImage.setVisibility(View.GONE); mPassportEntryAndExitImage.setVisibility(View.VISIBLE); } } /** * 注释：保持图片 * 时间：2019/3/1 0001 16:32 * 作者：郭翰林 */ private void savePhoto() { FileOutputStream fos = null; String cameraPath = Environment.getExternalStorageDirectory().getPath() + File.separator + \u0026#34;DCIM\u0026#34; + File.separator + \u0026#34;Camera\u0026#34;; //相册文件夹 File cameraFolder = new File(cameraPath); if (!cameraFolder.exists()) { cameraFolder.mkdirs(); } //保存的图片文件 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;yyyyMMdd_HHmmss\u0026#34;); String imagePath = cameraFolder.getAbsolutePath() + File.separator + \u0026#34;IMG_\u0026#34; + simpleDateFormat.format(new Date()) + \u0026#34;.jpg\u0026#34;; File imageFile = new File(imagePath); try { fos = new FileOutputStream(imageFile); fos.write(imageData); } catch (Exception e) { e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); Intent intent = new Intent(); intent.putExtra(KEY_IMAGE_PATH, imagePath); setResult(RESULT_OK, intent); } catch (IOException e) { setResult(RESULT_FIRST_USER); e.printStackTrace(); } } finish(); } } } Activity自定义布局 R.layout.activity_camre_layout\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!--相机预览视图--\u0026gt; \u0026lt;FrameLayout android:id=\u0026#34;@+id/camera_preview_layout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt;\u0026lt;/FrameLayout\u0026gt; \u0026lt;!--蒙版区域--\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;!--提示文字--\u0026gt; \u0026lt;RelativeLayout android:id=\u0026#34;@+id/camera_tip\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:background=\u0026#34;@drawable/tip_layout_shape\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;请参照辅助线进行拍摄\u0026#34; android:textColor=\u0026#34;#fff\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;!--蒙版图片--\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/mask_img\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginLeft=\u0026#34;20dp\u0026#34; android:layout_marginTop=\u0026#34;25dp\u0026#34; android:layout_marginRight=\u0026#34;20dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; android:src=\u0026#34;@mipmap/hk_macao_taiwan_passes_positive\u0026#34; android:visibility=\u0026#34;visible\u0026#34; /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/passport_entry_and_exit_img\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginLeft=\u0026#34;54dp\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:layout_marginRight=\u0026#34;54dp\u0026#34; android:layout_marginBottom=\u0026#34;50dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; android:src=\u0026#34;@mipmap/passport_entry_and_exit\u0026#34; android:visibility=\u0026#34;gone\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!--顶部视图--\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;15dp\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/flash_button\u0026#34; android:layout_width=\u0026#34;25dp\u0026#34; android:layout_height=\u0026#34;25dp\u0026#34; android:src=\u0026#34;@mipmap/flash_close\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!--拍照完成确定视图--\u0026gt; \u0026lt;RelativeLayout android:id=\u0026#34;@+id/ll_confirm_layout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:padding=\u0026#34;50dp\u0026#34; android:visibility=\u0026#34;gone\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/cancle_save_button\u0026#34; android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:src=\u0026#34;@mipmap/failed\u0026#34; /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/save_button\u0026#34; android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:src=\u0026#34;@mipmap/success\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;!--底部拍照按钮--\u0026gt; \u0026lt;RelativeLayout android:id=\u0026#34;@+id/ll_photo_layout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:padding=\u0026#34;15dp\u0026#34; android:visibility=\u0026#34;visible\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/cancle_button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:background=\u0026#34;@null\u0026#34; android:text=\u0026#34;取消\u0026#34; android:textColor=\u0026#34;#fff\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/take_photo_button\u0026#34; android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:src=\u0026#34;@mipmap/take_button\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 四、Demo链接 欢迎Star GitHub:https://github.com/RmondJone/AndroidCamera ","date":"2023-04-07T10:30:23+08:00","permalink":"https://rmondjone.github.io/posts/mobile/android_camre/","title":"Android自定义拍照实现"},{"content":"LockTableView 自定义表格,可锁定双向表头,自适应列宽、自适应行高、下拉刷新、上拉加载、链式调用、快速集成。\n效果展示 Github Github-LockTableView 欢迎大家点赞(Star)，你的鼓励是我前行的动力！我的宗旨：简单！实用！\n工程集成说明 第一步 1 2 3 4 5 6 7 8 //在工程gradle文件里 allprojects { repositories { ....... maven { url \u0026#39;https://jitpack.io\u0026#39; } ...... } } 1 2 3 4 5 6 //如果不在工程gradle文件里加入，也可以加入模块gradle文件中 repositories { maven { url \u0026#34;https://jitpack.io\u0026#34; } } 第二步 1 2 3 dependencies { compile \u0026#39;com.github.RmondJone:LockTableView:1.0.9\u0026#39; } API使用说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 final LockTableView mLockTableView = new LockTableView(this, mContentView, mTableDatas); Log.e(\u0026#34;表格加载开始\u0026#34;, \u0026#34;当前线程：\u0026#34; + Thread.currentThread()); mLockTableView.setLockFristColumn(true) //是否锁定第一列 .setLockFristRow(true) //是否锁定第一行 .setMaxColumnWidth(100) //列最大宽度 .setMinColumnWidth(60) //列最小宽度 .setMinRowHeight(20)//行最小高度 .setMaxRowHeight(60)//行最大高度 .setTextViewSize(16) //单元格字体大小 .setFristRowBackGroudColor(R.color.table_head)//表头背景色 .setTableHeadTextColor(R.color.beijin)//表头字体颜色 .setTableContentTextColor(R.color.border_color)//单元格字体颜色 .setNullableString(\u0026#34;N/A\u0026#34;) //空值替换值 .setTableViewListener(new LockTableView.OnTableViewListener() { //设置横向滚动监听 @Override public void onTableViewScrollChange(int x, int y) { Log.e(\u0026#34;滚动值\u0026#34;,\u0026#34;[\u0026#34;+x+\u0026#34;]\u0026#34;+\u0026#34;[\u0026#34;+y+\u0026#34;]\u0026#34;); } }) .setTableViewRangeListener(new LockTableView.OnTableViewRangeListener() { //设置横向滚动边界监听 @Override public void onLeft(HorizontalScrollView view) { Log.e(\u0026#34;滚动边界\u0026#34;,\u0026#34;滚动到最左边\u0026#34;); } @Override public void onRight(HorizontalScrollView view) { Log.e(\u0026#34;滚动边界\u0026#34;,\u0026#34;滚动到最右边\u0026#34;); } }) .setOnLoadingListener(new LockTableView.OnLoadingListener() { //下拉刷新、上拉加载监听 @Override public void onRefresh(final XRecyclerView mXRecyclerView, final ArrayList\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt; mTableDatas) { Log.e(\u0026#34;表格主视图\u0026#34;,mXRecyclerView); Log.e(\u0026#34;表格所有数据\u0026#34;,mTableDatas); //如需更新表格数据调用,部分刷新不会全部重绘 mLockTableView.setTableDatas(mTableDatas); //停止刷新 mXRecyclerView.refreshComplete(); } @Override public void onLoadMore(final XRecyclerView mXRecyclerView, final ArrayList\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt; mTableDatas) { Log.e(\u0026#34;表格主视图\u0026#34;,mXRecyclerView); Log.e(\u0026#34;表格所有数据\u0026#34;,mTableDatas); //如需更新表格数据调用,部分刷新不会全部重绘 mLockTableView.setTableDatas(mTableDatas); //停止刷新 mXRecyclerView.loadMoreComplete(); //如果没有更多数据调用 mXRecyclerView.setNoMore(true); } }) .setOnItemClickListenter(new LockTableView.OnItemClickListenter() { @Override public void onItemClick(View item, int position) { Log.e(\u0026#34;点击事件\u0026#34;,position+\u0026#34;\u0026#34;); } }) .setOnItemLongClickListenter(new LockTableView.OnItemLongClickListenter() { @Override public void onItemLongClick(View item, int position) { Log.e(\u0026#34;长按事件\u0026#34;,position+\u0026#34;\u0026#34;); } }) .setOnItemSeletor(R.color.dashline_color)//设置Item被选中颜色 .show(); //显示表格,此方法必须调用 mLockTableView.getTableScrollView().setPullRefreshEnabled(true); mLockTableView.getTableScrollView().setLoadingMoreEnabled(true); mLockTableView.getTableScrollView().setRefreshProgressStyle(ProgressStyle.SquareSpin); //属性值获取 Log.e(\u0026#34;每列最大宽度(dp)\u0026#34;, mLockTableView.getColumnMaxWidths().toString()); Log.e(\u0026#34;每行最大高度(dp)\u0026#34;, mLockTableView.getRowMaxHeights().toString()); Log.e(\u0026#34;表格所有的滚动视图\u0026#34;, mLockTableView.getScrollViews().toString()); Log.e(\u0026#34;表格头部固定视图(锁列)\u0026#34;, mLockTableView.getLockHeadView().toString()); Log.e(\u0026#34;表格头部固定视图(不锁列)\u0026#34;, mLockTableView.getUnLockHeadView().toString()); /** * 构造方法 * * @param mContext 上下文 * @param mContentView 表格父视图 * @param mTableDatas 表格数据 */ public LockTableView(Context mContext, ViewGroup mContentView, ArrayList\u0026lt;ArrayList\u0026lt;String\u0026gt;\u0026gt; mTableDatas) { this.mContext = mContext; this.mContentView = mContentView; this.mTableDatas = mTableDatas; initAttrs(); } 目前支持可自定义属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * 是否锁定首行 */ private boolean isLockFristRow = true; /** * 是否锁定首列 */ private boolean isLockFristColumn = true; /** * 最大列宽(dp) */ private int maxColumnWidth; /** * 最小列宽(dp) */ private int minColumnWidth; /** * 最大行高(dp) */ private int maxRowHeight; /** * 最小行高dp) */ private int minRowHeight; /** * 第一行背景颜色 */ private int mFristRowBackGroudColor; /** * 数据为空时的缺省值 */ private String mNullableString; /** * 单元格字体大小 */ private int mTextViewSize; /** * 表格头部字体颜色 */ private int mTableHeadTextColor; /** * 表格内容字体颜色 */ private int mTableContentTextColor; /** * 表格横向滚动监听事件 */ private OnTableViewListener mTableViewListener; /** * 表格横向滚动到边界监听事件 */ private OnTableViewRangeListener mTableViewRangeListener; /** * 表格上拉刷新、下拉加载监听事件 */ private OnLoadingListener mOnLoadingListener; /** * Item点击事件 */ private OnItemClickListenter mOnItemClickListenter; /** * Item长按事件 */ private OnItemLongClickListenter mOnItemLongClickListenter; /** * Item选中颜色 */ private int mOnItemSeletor; 问题反馈 技术交流群：QQ(264587303) Demo作者：郭翰林 注：有定制化需求自己下源码根据自己的需求改动，不要指望别人给你实现，这样永远没有成长！ 本控件实现没有难度，只要静心看代码都能看的懂。我只提供最基础的功能，尽量满足大部分的开发需求。 关于作者 掘金：https://juejin.im/user/5a2b6b306fb9a04522076dd0/posts 简书：https://www.jianshu.com/u/7566e4604f87 GitHub:https://github.com/RmondJone\nLicense 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Copyright (c) 2018 Guohanlin Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026#34;Software\u0026#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u0026#34;AS IS\u0026#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ","date":"2023-04-07T10:29:12+08:00","permalink":"https://rmondjone.github.io/posts/mobile/lock_table/","title":"Android一句话集成自定义表格"},{"content":"一、下载BBR多合一脚本并授予执行权限 1 2 3 4 5 6 7 8 #下载脚本 wget --no-check-certificate -O tcpx.sh https://raw.githubusercontent.com/ylx2016/Linux-NetSpeed/master/tcpx.sh #授予权限 chmod +x tcpx.sh #执行脚本 ./tcpx.sh 二、选择安装合适的加速内核并启动加速 安装内核和启动加速都会需要重启VPS服务器！！\n三、Docker搭建速度测试进行测试对比 这里使用了Docker搭建speedtest,下载对于镜像启动相关服务即可\n1 2 3 4 #下载docker镜像 docker pull adolfintel/speedtest #启动容器 docker run --name=speedtest -p 9001:80 adolfintel/speedtest 启动完成即可使用VPS的ip+对应端口访问网速测试网站,点击开始按钮即可进行测速\n四、BBR加速对比 1、不启动BBR加速，直接裸连 2、锐速 友情提示：Debian 9和10系统由于内核版本问题都不支持锐速\n3、BBR原版 ","date":"2023-04-07T10:28:08+08:00","permalink":"https://rmondjone.github.io/posts/other/vps_bbr/","title":"VPS服务器一键BBR加速教程--网速变10倍"},{"content":"前言 XRay是近几年兴起的科学上网技术，采用新的协议，因功能强大、能有效抵抗墙的干扰而广受好评。\n一、ACME配置SSL证书 安装socat和acme服务 1 2 3 4 5 # 安装socat apt install socat #安装acme curl https://get.acme.sh | sh acme 绑定域名邮箱 1 ~/.acme.sh/acme.sh --register-account -m my@example.com(随便啥邮箱) 阿里云创建AccessKey ID及AccessKey Secret，并配置环境变量 1 2 export Ali_Key=\u0026#34;Key_XXX\u0026#34; export Ali_Secret=\u0026#34;Secret_XXX\u0026#34; 申请证书 1 acme.sh --issue --dns dns_ali -d *.abc.com 定时任务保证了证书在到期前能自动续期,由于ACME协议和Let’s Encrypt CA都在频繁的更新，因此建议开启acme.sh的自动升级： 1 2 # 查看定时任务 crontab -l 1 ~/.acme.sh/acme.sh --upgrade --auto-upgrade 移动SSL到指定目录,例如我这里移动到 /root/ssl文件夹下，没有就去创建一个，后面面板会用到 1 2 3 4 ~/.acme.sh/acme.sh --install-cert -d 域名 \\ --cert-file /root/ssl/xxxxx.crt \\ --key-file /root/ssl/xxxxx.key \\ --fullchain-file /root/ssl/fullchain.crt 二、X-UI的Docker安装以及用户管理 安装XRay\n1 docker run --restart=always --name x-ui -d -v /root/x-ui/db:/etc/x-ui -v /root/ssl:/root/cert --network host enwaiax/x-ui:latest 54321端口是X-UI的管理端口安装完之后，通过你的服务器ip http://ip:54321 端口访问X-UI管理后台。\n三、自建协议转换Clash链接服务 安装subconverter转换服务 1 2 3 4 5 6 7 #订阅转换后端 docker run -d --name=subconverter --restart=always -p 9003:25500 stilleshan/subconverter #订阅转换前端 docker run -d --name subweb --restart always \\ -p 9005:80 \\ -e API_URL=\u0026#39;https://config.xxxx.xxxxx\u0026#39; \\ #首先要把订阅转换后端使用nginx反代 stilleshan/subweb 配置nginx反向代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server { listen 80; server_name config.xxxxx.xxxxx; location / { proxy_pass http://localhost:9003; } } server { listen 80; server_name subweb.xxxxx.xxxxx; location / { proxy_pass http://localhost:9005; } } 直接通过浏览器访问subweb.xxxxx.xxxxx，点击转换即可获得以下格式生成Clash订阅链接 1 http://config.xxxxx.xxxxx/sub?target=clash\u0026amp;url=%URL% 配置参考：https://github.com/tindy2013/subconverter/blob/master/README-cn.md\n","date":"2023-04-07T10:27:17+08:00","permalink":"https://rmondjone.github.io/posts/other/docker_xray/","title":"Docker搭建XRay用户管理以及流量伪装教程"},{"content":"一、前言 在日常开发中，测试阶段需要开发去手动打包，这样效率很低下，而且如果开发正在其他分支或者正在开发，打包也非常麻烦。所以在这个背景下，自动化打包平台的诞生显得尤为重要。\n二、基础概念介绍 Jenkins Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成\nGradle Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置\nFastlane Fastlane是用Ruby语言编写的一套自动化工具集和框架，每一个工具实际都对应一个Ruby脚本，用来执行某一个特定的任务，而fastlane核心框架则允许使用者通过类似配置文件的形式，将不同的工具有机而灵活的结合在一起，从而形成一个个完整的自动化流程。\n三、App自动化打包的搭建流程 第一步，搭建Jenkins，这个网上都有大量教程，我就不详细赘述了。\n第二步，搭建Android、IOS开发环境，这里网上也有大量教程，不在赘述\n第三步，书写Jenkins自动化打包脚本，Jenkins新建对应的任务\n总体来说，搭建App自动化打包的步骤主要就这3步。主要介绍的就是第3步，这里用我们工程里的脚本来详细说明，每行命令的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 pipeline { agent any parameters { string(name: \u0026#39;EMAIL\u0026#39;, defaultValue: \u0026#39;liang@xyz.cn\u0026#39;, description: \u0026#39;编译任务结束时通知的邮箱\u0026#39;) string(name: \u0026#39;PGYER_DESCRIPTION\u0026#39;, defaultValue: \u0026#39;\u0026#39;, description: \u0026#39;此次打包备注(可选,默认显示分支和此次任务Build ID)\u0026#39;) choice(choices: [\u0026#39;ANDROID\u0026#39;,\u0026#39;IOS\u0026#39;], description: \u0026#39;编译哪个平台?\u0026#39;, name: \u0026#39;BUILD_PLATFORM\u0026#39;) choice(choices: [\u0026#39;Debug\u0026#39;, \u0026#39;Preview\u0026#39;, \u0026#39;Release\u0026#39;], description: \u0026#39;编译什么版本?(Android P版请选择Preview不要用Release!!!)\u0026#39;, name: \u0026#39;BUILD_TYPE\u0026#39;) string(name: \u0026#39;FILE_NAME\u0026#39;, defaultValue: \u0026#39;xyz_app\u0026#39;, description: \u0026#39;输出安装包的文件名(尽量英文),不能为空\u0026#39;) string(name: \u0026#39;API_HOST\u0026#39;, defaultValue: \u0026#39;\u0026#39;, description: \u0026#39;接口地址,不改就留空\u0026#39;) string(name: \u0026#39;BUILD_VERSION_NAME\u0026#39;, defaultValue: \u0026#39;\u0026#39;, description: \u0026#39;版本号(格式:x.y.z),不改就留空\u0026#39;) string(name: \u0026#39;PGYER_API_KEY\u0026#39;, defaultValue: \u0026#39;43aad9a3e16b23382b6350e05546db49\u0026#39;, description: \u0026#39;蒲公英分发api key,不懂请保持默认\u0026#39;) string(name: \u0026#39;PGYER_USER_KEY\u0026#39;, defaultValue: \u0026#39;35f87a2f64bde6cfed825ae188e2c1f0\u0026#39;, description: \u0026#39;蒲公英分发user key,不懂请保持默认\u0026#39;) booleanParam(name:\u0026#39;UPDATE_POD\u0026#39;,defaultValue:false,description:\u0026#39;是否更新Pod库?\u0026#39;) choice(name:\u0026#39;POD_REPO\u0026#39;,choices:[\u0026#34;xyz-appdev-spec\u0026#34;,\u0026#34;artsy\u0026#34;,\u0026#34;master\u0026#34;],description:\u0026#39;具体更新哪一个Pod库\u0026#39;) booleanParam(name:\u0026#39;GRADLE_OFFLINE\u0026#39;,defaultValue:true,description:\u0026#39;是否采用Gradle离线模式?\u0026#39;) } environment { LANG = \u0026#34;en_US.UTF-8\u0026#34; //sentry cli cdn 链接 SENTRYCLI_CDNURL = \u0026#39;http://cdn.npm.taobao.org/dist/sentry-cli\u0026#39; //蒲公英 ipa路径 PGYER_IPA = \u0026#34;./build/XYZ_iOS.ipa\u0026#34; //蒲公英 上传描述 PGYER_UPDATE_DESCRIPTION = \u0026#34;Jenkins任务号: 【${BUILD_DISPLAY_NAME}】 本次编译的分支:【${BRANCH_NAME}】 编译类型:【${params.BUILD_TYPE}】 额外备注:【${params.PGYER_DESCRIPTION}】\u0026#34; //ios 输出目录 GYM_OUTPUT_DIRECTORY = \u0026#34;./build\u0026#34; //testFlight ipa 路径 PILOT_IPA = \u0026#34;${PGYER_IPA}\u0026#34; //testFlight 升级描述 PILOT_BETA_APP_DESCRIPTION = \u0026#34;${PGYER_UPDATE_DESCRIPTION}\u0026#34; FL_VERSION_NUMBER_VERSION_NUMBER = \u0026#34;${params.BUILD_VERSION_NAME}\u0026#34; } tools { nodejs \u0026#34;nodejs\u0026#34; } stages { stage(\u0026#39;Prepare\u0026#39;) { steps { sh \u0026#34;mkdir build \u0026amp;\u0026amp; printenv \u0026amp;\u0026amp; printenv \u0026gt; build/env.txt\u0026#34; script { if(\u0026#34;${params.BUILD_TYPE}\u0026#34; !=\u0026#34;Debug\u0026#34;){ sh \u0026#39;\u0026#39;\u0026#39; sed -i \u0026#34;s#sensorsAnalytics.disablePlugin=true#sensorsAnalytics.disablePlugin=false#g\u0026#34; android/gradle.properties \u0026#39;\u0026#39;\u0026#39; sh \u0026#34;cat android/gradle.properties\u0026#34; } sh \u0026#39;\u0026#39;\u0026#39; sed -i \u0026#34;s#{...getPersistenceFunctions(pageName)}##g\u0026#34; app/entry/App.js \u0026#39;\u0026#39;\u0026#39; sh \u0026#34;cat app/entry/App.js\u0026#34; if(\u0026#34;${params.BUILD_VERSION_NAME}\u0026#34; != \u0026#34;\u0026#34;){ sh \u0026#39;\u0026#39;\u0026#39; sed -i \u0026#34;s/\\\\(VersionName=\\\\)\\\\([0-9]\\\\{1,\\\\}\\\\.[0-9]\\\\{1,\\\\}\\\\.[0-9]\\\\{1,\\\\}\\\\)/\\\\1${BUILD_VERSION_NAME}/g\u0026#34; android/gradle.properties \u0026#39;\u0026#39;\u0026#39; sh \u0026#34;cat android/gradle.properties\u0026#34; sh \u0026#34;cd ios \u0026amp;\u0026amp; fastlane build_version\u0026#34; } if(\u0026#34;${params.API_HOST}\u0026#34; != \u0026#34;\u0026#34;){ sh \u0026#39;\u0026#39;\u0026#39; sed -i \u0026#34;s#https://app\\\\.xyz\\\\.cn#${API_HOST}#g\u0026#34; android/app/src/main/java/com/focustech/xyz/network/configuration/Host.java \u0026#39;\u0026#39;\u0026#39; sh \u0026#34;cat android/app/src/main/java/com/focustech/xyz/network/configuration/Host.java\u0026#34; sh \u0026#39;\u0026#39;\u0026#39; sed -i \u0026#34;s#https://app\\\\.xyz\\\\.cn#${API_HOST}#g\u0026#34; ios/XYZ_iOS/Resources/Plists/NetEnvironment.json \u0026#39;\u0026#39;\u0026#39; sh \u0026#34;cat ios/XYZ_iOS/Resources/Plists/NetEnvironment.json\u0026#34; } if(params.UPDATE_POD \u0026amp;\u0026amp; \u0026#34;${params.BUILD_PLATFORM}\u0026#34;==\u0026#39;IOS\u0026#39;){ sh \u0026#34;cd ios \u0026amp;\u0026amp; pod repo update ${params.POD_REPO}\u0026#34; } } } } stage(\u0026#39;Build\u0026#39;) { when { expression { return !params.UPDATE_POD } } steps { script { sh \u0026#39;npm install\u0026#39; if (\u0026#34;${params.BUILD_PLATFORM}\u0026#34; == \u0026#39;ANDROID\u0026#39;) { if(params.GRADLE_OFFLINE){ if (\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#34;Preview\u0026#34;){ sh \u0026#34;cd android \u0026amp;\u0026amp; bash gradlew --build-cache --offline assembleRelease\u0026#34; }else if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#34;Release\u0026#34;){ sh \u0026#34;cd android \u0026amp;\u0026amp; bash gradlew --build-cache --offline buildReinforceRelease\u0026#34; }else { sh \u0026#34;cd android \u0026amp;\u0026amp; bash gradlew --build-cache --offline assemble${params.BUILD_TYPE}\u0026#34; } }else{ if (\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#34;Preview\u0026#34;){ sh \u0026#34;cd android \u0026amp;\u0026amp; bash gradlew --build-cache assembleRelease\u0026#34; }else if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#34;Release\u0026#34;){ sh \u0026#34;cd android \u0026amp;\u0026amp; bash gradlew --build-cache buildReinforceRelease\u0026#34; }else { sh \u0026#34;cd android \u0026amp;\u0026amp; bash gradlew --build-cache assemble${params.BUILD_TYPE}\u0026#34; } } } else if (\u0026#34;${params.BUILD_PLATFORM}\u0026#34; == \u0026#39;IOS\u0026#39;){ sh \u0026#39;cd ios \u0026amp;\u0026amp; pod install --verbose\u0026#39; if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#39;Debug\u0026#39;){ sh \u0026#39;cd ios \u0026amp;\u0026amp; fastlane build\u0026#39; } else{ sh \u0026#39;cd ios \u0026amp;\u0026amp; fastlane build_ts\u0026#39; } } } } } stage(\u0026#39;Deploy\u0026#39;) { when { expression { return !params.UPDATE_POD } } steps { script { archiveArtifacts artifacts: \u0026#39;build/env.txt\u0026#39; if (\u0026#34;${params.BUILD_PLATFORM}\u0026#34; == \u0026#39;ANDROID\u0026#39;) { if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#39;Release\u0026#39;){ sh \u0026#34;mv android/app/build/outputs/apk/release/*.apk build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; sh \u0026#34;zip -r android/app/build/outputs/apk/release/${FILE_NAME}.zip android/app/build/outputs/apk/release/channels/\u0026#34; sh \u0026#34;mv android/app/build/outputs/apk/release/${FILE_NAME}.zip build/\u0026#34; archiveArtifacts artifacts: \u0026#34;build/*.apk\u0026#34; archiveArtifacts artifacts: \u0026#34;build/*.zip\u0026#34; }else if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#39;Debug\u0026#39;) { sh \u0026#34;mv android/app/build/outputs/apk/debug/*.apk build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; archiveArtifacts artifacts: \u0026#34;build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; }else if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#39;Preview\u0026#39;) { sh \u0026#34;mv android/app/build/outputs/apk/release/*.apk build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; archiveArtifacts artifacts: \u0026#34;build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; } sh \u0026#39;\u0026#39;\u0026#39; curl -F \u0026#34;file=@build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; -F \u0026#34;userKey=${PGYER_USER_KEY}\u0026#34; -F \u0026#34;_api_key=${PGYER_API_KEY}\u0026#34; -F \u0026#34;buildInstallType=2\u0026#34; -F \u0026#34;buildPassword=123456\u0026#34; -F \u0026#34;buildUpdateDescription=${PGYER_UPDATE_DESCRIPTION}\u0026#34; http://www.pgyer.com/apiv2/app/upload \u0026#39;\u0026#39;\u0026#39; } else if (\u0026#34;${params.BUILD_PLATFORM}\u0026#34; == \u0026#39;IOS\u0026#39;){ archiveArtifacts artifacts: \u0026#34;ios/build/*.ipa\u0026#34; archiveArtifacts artifacts: \u0026#34;ios/build/*.app.dSYM.zip\u0026#34; sh \u0026#34;mv ios/build/*.ipa build/${FILE_NAME}-${BUILD_TYPE}.ipa\u0026#34; sh \u0026#39;\u0026#39;\u0026#39; curl -F \u0026#34;file=@build/${FILE_NAME}-${BUILD_TYPE}.ipa\u0026#34; -F \u0026#34;userKey=${PGYER_USER_KEY}\u0026#34; -F \u0026#34;_api_key=${PGYER_API_KEY}\u0026#34; -F \u0026#34;buildInstallType=2\u0026#34; -F \u0026#34;buildPassword=123456\u0026#34; -F \u0026#34;buildUpdateDescription=${PGYER_UPDATE_DESCRIPTION}\u0026#34; http://www.pgyer.com/apiv2/app/upload \u0026#39;\u0026#39;\u0026#39; } } } } } post { failure { emailext attachLog: true, attachmentsPattern: \u0026#39;build/**\u0026#39;, body: \u0026#34;jenkins任务失败! ${PGYER_UPDATE_DESCRIPTION} 详情请点击:${BUILD_URL} 或直接从附件下载编译log自行查看!\u0026#34;, compressLog: true, replyTo: \u0026#39;\u0026#39;, subject: \u0026#39;jenkins任务失败,请排查问题\u0026#39;, to: \u0026#39;${EMAIL}\u0026#39; } aborted { emailext attachLog: true, attachmentsPattern: \u0026#39;build/**\u0026#39;, body: \u0026#34;jenkins任务中止! ${PGYER_UPDATE_DESCRIPTION} 详情请点击:${BUILD_URL}\u0026#34;, compressLog: true, replyTo: \u0026#39;\u0026#39;, subject: \u0026#39;jenkins任务已中止\u0026#39;, to: \u0026#39;${EMAIL}\u0026#39; } success { script { if(!params.UPDATE_POD){ if (\u0026#34;${params.BUILD_PLATFORM}\u0026#34; == \u0026#39;ANDROID\u0026#39;) { def packPath = \u0026#34;build/${FILE_NAME}-${BUILD_TYPE}.apk\u0026#34; echo \u0026#34;packPath:${packPath}\u0026#34; def packInfo = \u0026#34;\u0026#34;\u0026#34;${sh(returnStdout: true, script: \u0026#34;du -s ${packPath}\u0026#34;)}\u0026#34;\u0026#34;\u0026#34; def packSize = packInfo.substring(0, packInfo.indexOf(\u0026#39;\t\u0026#39;)) echo \u0026#34;packSize:${packSize}\u0026#34; def packSizeMb = packSize.toInteger() / 2 / 1000 def packSizeMbStr = \u0026#34;\u0026#34; + packSizeMb if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#39;Preview\u0026#39;){ if(packSizeMb \u0026gt; 40){ emailext body: \u0026#34;任务${BUILD_DISPLAY_NAME}安卓Preview包大小已经超过40Mb，现已达到${packSizeMbStr}Mb！\u0026#34;, compressLog: true, replyTo: \u0026#39;\u0026#39;, subject: \u0026#39;任务${BUILD_DISPLAY_NAME}安卓Preview包大小已经超过40Mb！\u0026#39;, to: \u0026#39;zhangwenxin@xyz.cn;guohanlin@xyz.cn;jinwenwu@xyz.cn;jinjianxin@xyz.cn\u0026#39; } } }else if (\u0026#34;${params.BUILD_PLATFORM}\u0026#34; == \u0026#39;IOS\u0026#39;){ def packPath = \u0026#34;build/${FILE_NAME}-${BUILD_TYPE}.ipa\u0026#34; echo \u0026#34;packPath:${packPath}\u0026#34; def packInfo = \u0026#34;\u0026#34;\u0026#34;${sh(returnStdout: true, script: \u0026#34;du -s ${packPath}\u0026#34;)}\u0026#34;\u0026#34;\u0026#34; def packSize = packInfo.substring(0, packInfo.indexOf(\u0026#39;\t\u0026#39;)) echo \u0026#34;packSize:${packSize}\u0026#34; def packSizeMb = packSize.toInteger() / 2 / 1000 def packSizeMbStr = \u0026#34;\u0026#34; + packSizeMb if(\u0026#34;${params.BUILD_TYPE}\u0026#34; == \u0026#39;Preview\u0026#39;){ if(packSizeMb \u0026gt; 40){ emailext body: \u0026#34;任务${BUILD_DISPLAY_NAME}苹果Preview包大小已经超过40Mb，现已达到${packSizeMbStr}Mb！\u0026#34;, compressLog: true, replyTo: \u0026#39;\u0026#39;, subject: \u0026#39;任务${BUILD_DISPLAY_NAME}苹果Preview包大小已经超过40Mb！\u0026#39;, to: \u0026#39;zhangwenxin@xyz.cn;guohanlin@xyz.cn;jinwenwu@xyz.cn;jinjianxin@xyz.cn\u0026#39; } } } } } script { if(!params.UPDATE_POD){ if(\u0026#34;${params.BUILD_PLATFORM}\u0026#34;==\u0026#34;IOS\u0026#34;){ emailext body: \u0026#34;jenkins任务成功! ${PGYER_UPDATE_DESCRIPTION} 详情请点击:${BUILD_URL} 或直接通过蒲公英下载! iOS下载链接 http://www.pgyer.com/xyz_ios\u0026#34;, compressLog: true, replyTo: \u0026#39;\u0026#39;, subject: \u0026#39;jenkins任务成功,请下载安装\u0026#39;, to: \u0026#39;${EMAIL}\u0026#39; } else{ emailext body: \u0026#34;jenkins任务成功! ${PGYER_UPDATE_DESCRIPTION} 详情请点击:${BUILD_URL} 或直接通过蒲公英下载! Android下载链接 http://www.pgyer.com/xyz_android\u0026#34;, compressLog: true, replyTo: \u0026#39;\u0026#39;, subject: \u0026#39;jenkins任务成功,请下载安装\u0026#39;, to: \u0026#39;${EMAIL}\u0026#39; } } } } } } 首先我们来大致说下这个文件的大概意思，网上也有教程不明白的，可以再上网多找找资料。\n第一大块parameters，这里面主要定义了一些任务的参数，例如我要打哪个平台的包啊、版本号啊、邮件通知啊这些。\n第二大块environment，这里面主要定义了一些任务执行的环境以及预定义的一些全局的环境变量\n第三大块stages，这里是比较重要的一块内容，这里主要定义了一些任务的阶段性任务，以及这个阶段性任务执行哪些脚本。\n就好像上面的脚本，我把整个大任务分为了3个子任务：\n第一个子任务stage(\u0026lsquo;Prepare\u0026rsquo;），主要定义了一些我要打包前需要做的一些事情，例如执行npm、替换工程中部分代码等等。 第二个子任务stage(\u0026lsquo;Build\u0026rsquo;)，主要就是执行真正的打包流程，例如Android走了Gradle脚本去执行打包，IOS走了FastLane去执行打包。 第三个子任务stage(\u0026lsquo;Deploy\u0026rsquo;)，主要执行打包完之后的一些操作，例如打出的包的归档操作、包大小检测、上传蒲公英操作、上传蒲公英之后邮件通知操作 四、Android、IOS打包脚本详解 我们先来看Android，这里需要你有一定的Gradle基础，可以自己写简单的Gradle任务。从上面的Jenkins脚本，我们可以看到Android在打包的时候，区分了编译版本，debug和preview的直接调用Android自带的打包脚本assembleDebug、assembleRelease，Release版本也就是发布版本，这里我们做了自定义Gradle脚本buildReinforceRelease，为什么我们要自定义，因为通常我们上线发布的时候都需要加固APK并且做多渠道操作。如果每次都去手动用工具操作的话，这个是个很蛋疼的活。下面我们来看看这个脚本里有什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 ext { //加固插件路径 reinforce_plugin_path = \u0026#34;${project.rootDir}/reinforce\u0026#34; //360加固账号 reinforce_plugin_name = \u0026#39;xxxxxxxx\u0026#39; reinforce_plugin_passward = \u0026#39;xxxxxxx\u0026#39; //签名信息 key_store_path = \u0026#34;${project.rootDir}/app/xyz.keystore\u0026#34; key_store_passward = \u0026#39;xxxxxxxxx\u0026#39; alias = \u0026#39;xxxx\u0026#39; alias_passward = \u0026#39;xxxxxxxxxx\u0026#39; //Release Apk输出路劲 release_apk_path = \u0026#34;${project.buildDir}/outputs/apk/release/app-release.apk\u0026#34; //渠道配置文件 chanel_config_path = \u0026#34;${reinforce_plugin_path}/channel.txt\u0026#34; //渠道Apk输出路径 channel_apks_path = \u0026#34;${project.buildDir}/outputs/apk/release/channels/\u0026#34; } /** * 注释：编译加固渠道包 * 时间：2019/1/2 0002 14:01 * 作者：郭翰林 */ task buildReinforceRelease() { group \u0026#39;360reinforce\u0026#39; dependsOn(\u0026#39;assembleRelease\u0026#39;) doLast { //第一步：清空缓存 cleanFilesPath(reinforce_plugin_path + \u0026#34;/.cache\u0026#34;) cleanFilesPath(reinforce_plugin_path + \u0026#34;/output\u0026#34;) cleanFilesPath(reinforce_plugin_path + \u0026#34;/jiagu.db\u0026#34;) cleanFilesPath(reinforce_plugin_path + \u0026#34;/tempAndroidManifest.xml\u0026#34;) cleanFilesPath(channel_apks_path) //第二步：开始加固 reinforceApk() //清除无用缓存 cleanFilesPath(reinforce_plugin_path + \u0026#34;/.cache\u0026#34;) cleanFilesPath(reinforce_plugin_path + \u0026#34;/output\u0026#34;) cleanFilesPath(reinforce_plugin_path + \u0026#34;/jiagu.db\u0026#34;) cleanFilesPath(reinforce_plugin_path + \u0026#34;/tempAndroidManifest.xml\u0026#34;) } } /** * 注释：使用360加固加固Release包 * 时间：2019/1/2 0002 14:32 * 作者：郭翰林 */ def reinforceApk() { println(\u0026#39;开始进行加固操作\u0026#39;) File releaseApk = new File(release_apk_path) if (!releaseApk.exists()) { throw new FileNotFoundException(\u0026#34;Release包不存在，无法进行加固操作,文件路径：${releaseApk.getAbsolutePath()}\u0026#34;) } //创建渠道文件夹 File channelApksPath = new File(channel_apks_path) if (!channelApksPath.exists()) { channelApksPath.mkdir() } exec { commandLine \u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;chmod +x ${reinforce_plugin_path}/java/bin/*\u0026#34; } exec { commandLine \u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;java -jar ${reinforce_plugin_path}/jiagu.jar -login ${reinforce_plugin_name} ${reinforce_plugin_passward}\u0026#34; } exec { commandLine \u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;java -jar ${reinforce_plugin_path}/jiagu.jar -importsign ${key_store_path} ${key_store_passward} ${alias} ${alias_passward}\u0026#34; } exec { commandLine \u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;java -jar ${reinforce_plugin_path}/jiagu.jar -importmulpkg ${chanel_config_path}\u0026#34; } exec { commandLine \u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;java -jar ${reinforce_plugin_path}/jiagu.jar -jiagu ${release_apk_path} ${channel_apks_path} -autosign -automulpkg\u0026#34; } println(\u0026#39;加固操作结束，加固包路径\u0026#39; + channelApksPath.getAbsolutePath()) } /** * 注释：清空文件夹 * 时间：2019/1/2 0002 14:15 * 作者：郭翰林 */ def cleanFilesPath(String path) { File files = new File(path) if (!files.exists()) { return } println(\u0026#39;开始执行清除:\u0026#39; + files.getAbsolutePath()) if (files.isDirectory()) { String[] content = files.list()//取得当前目录下所有文件和文件夹 for (String name : content) { File temp = new File(path, name) if (temp.isDirectory()) {//判断是否是目录 cleanFilesPath(temp.getAbsolutePath())//递归调用，删除目录里的内容 temp.delete() } else { temp.delete() } } } files.delete() } 可以看到这里我们使用了360加固来执行加固和打渠道包的操作，那么我们怎么去把360加固引到工程里呢？答案很简单，直接360官网下载，然后直接拉360安装路径的文件夹到工程里。如下图所示：\nAndroid的部分就介绍到这，下面我们来看IOS打包脚本部分，前面说到IOS是通过FastLane去实现打包的，但众所周知，IOS打包需要证书以及签名，这个我们在FastLane脚本里改怎么去配置？\n关于Fastlane怎么集成，怎么部署网上都有教程这里不去赘述，这里主要说的就是Fastlane里的脚本该如何去书写，怎么去配置证书以及签名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 # This file contains the fastlane.tools configuration # You can find the documentation at https://docs.fastlane.tools # # For a list of all available actions, check out # # https://docs.fastlane.tools/actions # # For a list of all available plugins, check out # # https://docs.fastlane.tools/plugins/available-plugins # # Uncomment the line if you want fastlane to automatically update itself # update_fastlane default_platform(:ios) platform :ios do desc \u0026#34;build projcet\u0026#34; #配置Fastlane任务 lane :build do #配置工程基本信息 update_app_identifier( xcodeproj: \u0026#34;XYZ_iOS.xcodeproj\u0026#34;, # Optional path to xcodeproj, will use the first .xcodeproj if not set plist_path: \u0026#34;XYZ_iOS/XYZ_iOS-Info.plist\u0026#34;, # Path to info plist file, relative to xcodeproj app_identifier: \u0026#34;com.focuschina.xyz\u0026#34; # The App Identifier ) #配置签名以及证书 automatic_code_signing( path: \u0026#34;XYZ_iOS.xcodeproj\u0026#34;, #启用自动签名 use_automatic_signing: true, code_sign_identity: \u0026#34;iPhone Developer\u0026#34;, #根据证书拿到团队ID或者直接去苹果开发者官方查阅 team_id:\u0026#34;HB2YRTXXXXX\u0026#34;, ) #配置生成包的类型以及发布渠道 gym(scheme: \u0026#34;XYZ_iOS\u0026#34;, workspace: \u0026#34;XYZ_iOS.xcworkspace\u0026#34;, configuration: \u0026#34;Debug\u0026#34;, clean: true, output_name:\u0026#34;XYZ_iOS.ipa\u0026#34;, export_xcargs:\u0026#34;-allowProvisioningUpdates\u0026#34;, export_method: \u0026#34;development\u0026#34; # app-store, ad-hoc, package, enterprise, development, developer-id ) end lane :build_ts do update_app_identifier( xcodeproj: \u0026#34;XYZ_iOS.xcodeproj\u0026#34;, # Optional path to xcodeproj, will use the first .xcodeproj if not set plist_path: \u0026#34;XYZ_iOS/XYZ_iOS-Info.plist\u0026#34;, # Path to info plist file, relative to xcodeproj app_identifier: \u0026#34;com.focuschina.xyz\u0026#34; # The App Identifier ) automatic_code_signing( path: \u0026#34;XYZ_iOS.xcodeproj\u0026#34;, use_automatic_signing: true, code_sign_identity: \u0026#34;iPhone Developer\u0026#34;, team_id:\u0026#34;HB2YRXXXXXX\u0026#34;, ) gym(scheme: \u0026#34;XYZ_iOS\u0026#34;, workspace: \u0026#34;XYZ_iOS.xcworkspace\u0026#34;, configuration: \u0026#34;Release\u0026#34;, clean: true, output_name:\u0026#34;XYZ_iOS.ipa\u0026#34;, export_xcargs:\u0026#34;-allowProvisioningUpdates\u0026#34;, export_method: \u0026#34;app-store\u0026#34; # app-store, ad-hoc, package, enterprise, development, developer-id ) end lane :build_number do increment_build_number(build_number: ENV[\u0026#34;BUILD_VERSION_CODE\u0026#34;]) end lane :build_version do increment_version_number end lane :upload do pgyer end lane :upload_ts do upload_to_testflight end end 从上面可以看到定义了很多lane: XXX do,这个就是定义Fastlane的任务的原子操作，翻阅上面Jenkins脚本，最后调用的打包脚本也就是这里的任务。\n五、Jenkins里的任务配置 前面几个章节已经说了怎么去书写Jenkinsfile脚本以及Android、IOS的打包脚本该怎么去写。下面我们来详细说说，怎么把这些部署到Jenkins，变成可视化的配参任务。\n第一步，首先新建一个Item任务，然后选择多分支流水\n第二步，配置任务的分支源，以及编译配置\n对，这里我们直接填写Jenkinsfile的名称即可，因为我的Jenkins脚本是直接放在工程根目录下的，如果你不是放在根目录，则需要填写正确的层级。\n第三步 点击保存，则可以在Jenkins主面板看到新建的多分支流水任务，第一次运行可能看不到可视化参数配置，需要第二次运行分支脚本才可以看到可视化参数配置。\n","date":"2023-04-07T10:25:32+08:00","permalink":"https://rmondjone.github.io/posts/devops/app_ci/","title":"App自动化打包平台的搭建与维护"},{"content":"前言 目前Android工程 APK包体积逐渐增大，从压缩图片来说是一个解决方案，但是目前网上都没有什么好用的傻瓜式的批量压缩方案，无意中发现Pngquant可以去做这一件事，但是也只能单个文件夹压缩，无法遍历整个工程文件进行图片压缩处理。\n在这个背景下，我觉得开发一个Python脚本结合Pngquant去做这件事情还是有必要的\n环境搭建 Pngquant：直接去官网下载，然后加入到环境变量，在命令行可以运行pngquant -h没问题即可 下载可执行文件，解压找到对应平台的可执行文件双击运行即可。 Git源码 https://github.com/RmondJone/PicPngquant\n脚本介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import os import platform import threading # 压缩线程（同步压缩） class CompressThread(threading.Thread): # 构造方法 def __init__(self, rootPath, compressFile, compressPath, extensionName) -\u0026gt; None: threading.Thread.__init__(self) self.root = rootPath self.compressFile = compressFile self.path = compressPath self.extension = extensionName # 运行方法 def run(self) -\u0026gt; None: print(\u0026#34;\\n线程开始运行，压缩图片路径为：\u0026#34; + self.path) # 获得锁 threadLock.acquire() cmd = \u0026#34;pngquant 256 --quality=65-80 --skip-if-larger --force --ext .png \u0026#34; + self.path os.system(cmd) # 重命名后缀 if self.extension == \u0026#39;jpg\u0026#39; or self.extension == \u0026#39;jpeg\u0026#39;: os.remove(self.path) os.rename(os.path.join(self.root, self.compressFile + \u0026#34;.png\u0026#34;), os.path.join(self.root, self.compressFile)) # 释放锁 threadLock.release() print(\u0026#34;\\n线程结束运行，压缩图片路径为：\u0026#34; + self.path) if __name__ == \u0026#39;__main__\u0026#39;: tag = \u0026#34;\u0026#34;\u0026#34; _____ _ _____ _ | __ (_) | __ \\ | | | |__) | ___ ______| |__) | __ __ _ __ _ _ _ __ _ _ __ | |_ | ___/ |/ __|______| ___/ \u0026#39;_ \\ / _` |/ _` | | | |/ _` | \u0026#39;_ \\| __| | | | | (__ | | | | | | (_| | (_| | |_| | (_| | | | | |_ |_| |_|\\___| |_| |_| |_|\\__, |\\__, |\\__,_|\\__,_|_| |_|\\__| __/ | | | |___/ |_| \u0026#34;\u0026#34;\u0026#34; print(tag) excludeDir = [] isNeedExclude = input(\u0026#34;是否需要配置排除压缩文件夹(Y/N)：\u0026#34;) if isNeedExclude == \u0026#34;Y\u0026#34; or isNeedExclude == \u0026#34;y\u0026#34;: excludeDirStr = input(\u0026#34;请输入需要排除压缩的文件夹(多个以空格分隔)：\u0026#34;) excludeDir = excludeDirStr.split(\u0026#34; \u0026#34;) print(\u0026#34;当前配置的排除压缩文件夹为：\u0026#34;) print(excludeDir) # 创建压缩线程 def addThread(rootPath, compressFile, compressPath, extensionName): compressThread = CompressThread(rootPath, compressFile, compressPath, extensionName) compressThread.start() threads.append(compressThread) if os.system(\u0026#34;pngquant --version\u0026#34;) != 0: print(\u0026#34;\\n未检测到pngquant命令行环境，请参照pngquant官网搭建命令行环境：https://pngquant.org/\u0026#34;) else: dirPath = input(\u0026#34;请选择需要压缩的文件夹路径：\u0026#34;) # 去除输入路径首位空格 dirPath = dirPath.rstrip() dirPath = dirPath.lstrip() print(dirPath) # 初始化线程锁 threadLock = threading.Lock() # 压缩线程数组 threads = [] # 开始历遍所有图片 for root, dirs, files in os.walk(dirPath): # 当前路径下所有的图片加入压缩线程 for childFile in files: # 文件名 childFilePath = os.path.join(root, childFile) father_path = os.path.abspath(os.path.dirname(childFilePath) + os.path.sep + \u0026#34;.\u0026#34;) father_name = os.path.basename(father_path) if father_name not in excludeDir: # 扩展名 extension = os.path.splitext(childFilePath)[1][1:] if platform.system() != \u0026#39;Windows\u0026#39;: if extension == \u0026#39;png\u0026#39; or extension == \u0026#39;jpg\u0026#39; or extension == \u0026#39;jpeg\u0026#39;: addThread(root, childFile, childFilePath, extension) else: # Windows版pngquant只支持png压缩 if extension == \u0026#39;png\u0026#39;: addThread(root, childFile, childFilePath, extension) # 开始遍历执行压缩线程 for thread in threads: thread.join() 核心代码，主要就是使用python去遍历配置文件中定义的要压缩的文件夹，然后创建同步线程执行Pngquant压缩处理。\n\u0026ndash;quality=65-80：压缩图片质量为65-80 \u0026ndash;skip-if-larger：舍弃意义不大的压缩 \u0026ndash;ext .png：这个是因为默认它会将解压缩后的Png文件重命名加后缀，这个参数即将重命名后加了一个空的字符的后缀，即等于不重命名了 \u0026ndash;force：不重命名后等于要覆盖原来的文件了，这里即强制覆盖原来的文件 ","date":"2023-04-07T10:23:05+08:00","permalink":"https://rmondjone.github.io/posts/other/pngquant_python/","title":"Python结合Pngquant给工程做图片批量压缩"},{"content":"一、背景 在日常工作中，我们会使用蒲公英上传我们的APK，用来测试。每次打包，然后再去找到包，再上传到蒲公英，流程很繁琐，于是我想着把这些操作写成gralde脚本来简化这些操作。\n二、脚本的实现 利用蒲公英开发出的Api https://www.pgyer.com/doc/view/api#uploadApp，调用curl命令直接上传Apk包到蒲公英上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 import groovy.json.JsonBuilder import groovy.json.JsonSlurper import org.apache.tools.ant.taskdefs.condition.Os //https://www.pgyer.com/doc/view/api#uploadApp ext { api_key = \u0026#34;xxxxxxxxxxxxxxxxxx\u0026#34; user_key = \u0026#34;xxxxxxxxxxxxxxxxxx\u0026#34; // Apk输出路劲 apk_path = \u0026#34;${project.rootDir}/apks\u0026#34; } /** * 注释：打包Debug包并上传蒲公英 * 时间：2021/7/5 0005 15:06 * 作者：郭翰林 */ task pgyerBuildDebug() { group \u0026#39;pgyer\u0026#39; dependsOn(\u0026#39;assembleDebug\u0026#39;) doLast { def apkFileTree = fileTree(dir: apk_path, includes: [\u0026#34;**/*.apk\u0026#34;]) apkFileTree.each { File file -\u0026gt; def newFile = renameFileName(file) uploadApp(newFile, \u0026#34;[Debug]${newFile.name}\u0026#34;) } } } /** * 注释：打包Release并上传蒲公英 * 时间：2021/7/5 0005 15:07 * 作者：郭翰林 */ task pgyerBuildRelease() { group \u0026#39;pgyer\u0026#39; dependsOn(\u0026#39;assembleRelease\u0026#39;) doLast { def apkFileTree = fileTree(dir: apk_path, includes: [\u0026#34;**/*.apk\u0026#34;]) apkFileTree.each { File file -\u0026gt; def newFile = renameFileName(file) uploadApp(newFile, \u0026#34;[Release]${newFile.name}\u0026#34;) } } } /** * 注释：获取Git分支 * 时间：2021/9/8 0008 10:59 * 作者：郭翰林 * @return */ def loadGitBranch() { def config = file(\u0026#34;${project.rootDir}/.git/HEAD\u0026#34;) String content = \u0026#34;\u0026#34; config.eachLine { line -\u0026gt; content = line } return content.replaceAll(\u0026#34;ref: refs/heads/\u0026#34;, \u0026#34;\u0026#34;) } /** * 注释：重命名APK，解决执行删除之后打包名称没有变化的Bug * 时间：2021/7/29 0029 23:19 * 作者：郭翰林 * @param file * @return */ def renameFileName(File file) { def names = file.name.split(\u0026#34;-\u0026#34;) def appName = names[0] def buildType = names[1] def versionNo = names[2] def buildTime = project.hasProperty(\u0026#39;BUILD_TIME\u0026#39;) ? BUILD_TIME : new Date().format(\u0026#34;yyyyMMddHHmm\u0026#34;, TimeZone.getTimeZone(\u0026#34;GMT+08:00\u0026#34;)) File newFile = new File(apk_path, \u0026#34;${appName}-${buildType}-${versionNo}-${buildTime}.apk\u0026#34;) file.renameTo(newFile) return newFile } /** * 注释：删除apk输出文件夹 * 时间：2021/7/28 0028 15:35 * 作者：郭翰林 */ task deleteApkPath() { doLast { delete apk_path println(\u0026#34;*******************APK输出目录已删除***********************\u0026#34;) } } /** * 注释：打包Task任务依赖注入deleteApkPath * 时间：2021/7/28 0028 15:38 * 作者：郭翰林 */ project.tasks.whenTaskAdded { Task currentTask -\u0026gt; if (currentTask.name == \u0026#34;assembleDebug\u0026#34; || currentTask.name == \u0026#34;assembleRelease\u0026#34;) { currentTask.dependsOn(\u0026#39;deleteApkPath\u0026#39;) currentTask.mustRunAfter(\u0026#39;deleteApkPath\u0026#39;) } } /** * 注释：上传App至蒲公英 * 时间：2021/7/5 0005 15:13 * 作者：郭翰林 */ def uploadApp(File file, String description) { def out = new ByteArrayOutputStream() exec { if (Os.isFamily(Os.FAMILY_WINDOWS)) { ExecSpec execSpec = commandLine \u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;curl -F _api_key=${api_key} -F userKey=${user_key} -F file=@${file.absolutePath} -F buildInstallType=2 -F buildPassword=xxxxxx -F buildUpdateDescription=${description} https://www.pgyer.com/apiv2/app/upload\u0026#34; execSpec.standardOutput = out } else { ExecSpec execSpec = commandLine \u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;curl -F _api_key=${api_key} -F userKey=${user_key} -F file=@${file.absolutePath} -F buildInstallType=2 -F buildPassword=xxxxxx -F buildUpdateDescription=${description} https://www.pgyer.com/apiv2/app/upload\u0026#34; execSpec.standardOutput = out } } println(\u0026#34;蒲公英上传结果：\\n${out.toString()}\u0026#34;) def uploadResult = new JsonSlurper().parseText(out.toString()) if (uploadResult.code == 0) { sendMsgToDing(getFileSize(file), uploadResult.data) } else { println(\u0026#34;蒲公英上传失败原因:${uploadResult.message}\u0026#34;) } } /** * 注释：获取文件大小 * 时间：2021/7/30 0030 8:56 * 作者：郭翰林 * @param file */ def getFileSize(File file) { long size = file.size() if (size \u0026lt; 1024) { return \u0026#34;${new BigDecimal(size).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue()}B\u0026#34; } else if (size \u0026lt; 1024 * 1024) { return \u0026#34;${new BigDecimal(size / 1024).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue()}KB\u0026#34; } else if (size \u0026lt; 1024 * 1024 * 1024) { return \u0026#34;${new BigDecimal(size / 1024 / 1024).setScale(1, BigDecimal.ROUND_HALF_UP).doubleValue()}MB\u0026#34; } } /** * 注释：发送钉钉通知 * 时间：2021/7/29 0029 20:01 * 作者：郭翰林 * @param data * @return */ def sendMsgToDing(def fileSize, def data) { def conn = new URL(\u0026#34;https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;).openConnection() conn.setRequestMethod(\u0026#39;POST\u0026#39;) conn.setRequestProperty(\u0026#34;Connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;) conn.setRequestProperty(\u0026#34;Content-type\u0026#34;, \u0026#34;application/json;charset=UTF-8\u0026#34;) conn.setConnectTimeout(30000) conn.setReadTimeout(30000) conn.setDoInput(true) conn.setDoOutput(true) def dos = new DataOutputStream(conn.getOutputStream()) def qrCodeUrl = \u0026#34;![](\u0026#34; + data.buildQRCodeURL + \u0026#34;)\u0026#34; def _title = \u0026#34;蒲公英机器人\u0026#34; def _content = new StringBuffer() _content.append(\u0026#34;\\n\\n### Android构建成功,已上传蒲公英\u0026#34;) _content.append(\u0026#34;\\n\\n**构建应用**:\\n\\nxxxApp\u0026#34;) _content.append(\u0026#34;\\n\\n**构建时间**:\\n\\n${data.buildUpdated}\u0026#34;) _content.append(\u0026#34;\\n\\n**构建描述**:\\n\\n${data.buildUpdateDescription}\u0026#34;) _content.append(\u0026#34;\\n\\n**蒲公英版本号**:\\n\\nbuild${data.buildBuildVersion}\u0026#34;) _content.append(\u0026#34;\\n\\n**Android包大小**:\\n\\n${fileSize}\u0026#34;) _content.append(\u0026#34;\\n\\n**Android版本号**:\\n\\n${data.buildVersion}\u0026#34;) _content.append(\u0026#34;\\n\\n**Git分支**:\\n\\n${loadGitBranch()}\u0026#34;) _content.append(\u0026#34;\\n\\n**下载地址**:\\n\\nhttps://www.pgyer.com/${data.buildKey}\u0026#34;) _content.append(\u0026#34;\\n\\n**安装密码**:\\n\\ncarzone123\u0026#34;) _content.append(\u0026#34;\\n\\n\u0026#34; + qrCodeUrl) def json = new JsonBuilder() json { msgtype \u0026#34;markdown\u0026#34; markdown { title _title text _content.toString() } at { atMobiles([]) isAtAll false } } dos.writeBytes(json.toString()) def input = new BufferedReader(new InputStreamReader(conn.getInputStream())) String line = \u0026#34;\u0026#34; String result = \u0026#34;\u0026#34; while ((line = input.readLine()) != null) { result += line } dos.flush() dos.close() input.close() conn.connect() println(\u0026#34;钉钉发送通知结果:\\n${result}\u0026#34;) println(\u0026#34;*************** 钉钉消息已发送 ***************\u0026#34;) } ","date":"2023-04-07T10:11:30+08:00","permalink":"https://rmondjone.github.io/posts/devops/gradle_pgyer/","title":"Gradle结合蒲公英做一键上传打包至蒲公英"},{"content":"#查看某条规则下的防火墙开放端口\n1 2 3 4 #查看全部规则 iptables -L --line-numbers #查看ufw-user-input 规则 iptables -L ufw-user-input --line-numbers #授权开放防火墙端口\n1 iptables -I INPUT -p tcp --dport 795 -j ACCEPT #授权关闭防火墙端口\n1 iptables -D INPUT -p tcp --dport 8888 -j ACCEPT #删除某条规则\n1 iptables -D ufw-user-input 6 #查看正常服务的对外端口\n1 netstat -tlpn #保存防火墙规则\n如果没有安装iptables-persistent则先安装iptables-persistent\n1 sudo apt-get install iptables-persistent 输入以下命令保存规则持续生效\n1 2 netfilter-persistent save netfilter-persistent reload ","date":"2023-04-07T10:09:29+08:00","permalink":"https://rmondjone.github.io/posts/other/debain_iptables/","title":"Debian 10 iptables防火墙常用命令"},{"content":"一、背景 目前的IOS打包不支持蒲公英上传，并且原有的打包脚本是基于Python直接调用xcodebuild来完成打包操作,有以下几个缺点：\n● 脚本书写繁杂难以理解，不方便日后维护，并且脚本中强依赖项目路径，可移植性比较差 ● 脚本强依赖Python执行环境 ● 只有单纯的打包功能，没有上传蒲公英、钉钉通知等功能 ● 打完包之后无法区分是哪一个分支、哪一个时间段打的包\n在以上的背景之下，我基于FastLane+Python重新开发了一套打包机制，并有较强的可移植性。\n二、实现效果 只需工程根目录执行脚本PgyerBuild Debug即可完成打包+上传蒲公英+钉钉通知 三、脚本集成步骤 ● 机器安装FastLane，我使用的版本是2.189.1 ● 工程内集成FastLane，修改FastLane配置文件，第四章会给出配置模板 ● 拖入Python工程生成的脚本PgyerBuild到工程根目录(Python脚本内只需修改工程名即可) ● 集成完毕！执行打包脚本，即可完成打包+上传蒲公英+钉钉通知\n脚本使用教程\n1 2 3 4 #打Debug包 PgyerBuild Debug #打Release包 PgyerBuild Release 四、脚本源码 Python脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 # This is a sample Python script. import json # Press ⇧F10 to execute it or replace it with your code. # Press Double ⇧ to search everywhere for classes, files, tool windows, actions, and settings. import os import re import sys import time import requests # 时间格式化字符串 time_format = \u0026#39;%Y%m%d%H%M%S\u0026#39; # 当前路径 basedir = os.path.dirname(os.path.realpath(sys.argv[0])) # 蒲公英Apikey api_key = \u0026#34;cd17b24dxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; # 蒲公英UserKey user_key = \u0026#34;7058cxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; # 工程名称 projectName = \u0026#34;TooWellMerchant\u0026#34; # 获取系统当前时间并转换请求数据所需要的格式 def getTime(format_str): now = int(time.time()) timeStruct = time.localtime(now) strTime = time.strftime(format_str, timeStruct) return strTime # 执行IOS打包 def fastlane(buildType): if buildType == \u0026#34;Debug\u0026#34;: os.system(\u0026#34;fastlane buildDebug\u0026#34;) else: os.system(\u0026#34;fastlane buildRelease\u0026#34;) # 获取Git分支号 def getGitBranch(): with open(f\u0026#39;{basedir}/.git/HEAD\u0026#39;) as f: return f.read().replace(\u0026#34;ref: refs/heads/\u0026#34;, \u0026#34;\u0026#34;) # 获取版本号 def getVersionNo(): with open(f\u0026#39;{basedir}/{projectName}.xcodeproj/project.pbxproj\u0026#39;) as f: content = f.read() return re.findall(r\u0026#34;MARKETING_VERSION = (.+?);\u0026#34;, content)[0] # 上传蒲公英 def uploadPyger(buildType): if buildType == \u0026#39;Debug\u0026#39;: description = f\u0026#39;[Debug]business-debug-v{getVersionNo()}-{getTime(time_format)}.ipa\u0026#39; else: description = f\u0026#39;[Release]business-release-v{getVersionNo()}-{getTime(time_format)}.ipa\u0026#39; cmd = f\u0026#39;curl -F _api_key={api_key} -F userKey={user_key} -F file=@{basedir}/{projectName}.ipa -F \u0026#39; \\ f\u0026#39;buildInstallType=2 -F buildPassword=carzone123 -F buildUpdateDescri\u0026#39; \\ f\u0026#39;ption={description} https://www.pgyer.com/apiv2/app/upload \u0026#39; print(f\u0026#39;正在执行上传脚本:{cmd}\u0026#39;) result = os.popen(cmd) resultStr = result.read() print(f\u0026#39;蒲公英上传结果:{resultStr}\u0026#39;) return json.loads(resultStr) # 获取文件大小 def getFileSize(size): def strofsize(integer, remainder, level): if integer \u0026gt;= 1024: remainder = integer % 1024 integer //= 1024 level += 1 return strofsize(integer, remainder, level) else: return integer, remainder, level units = [\u0026#39;B\u0026#39;, \u0026#39;KB\u0026#39;, \u0026#39;MB\u0026#39;, \u0026#39;GB\u0026#39;, \u0026#39;TB\u0026#39;, \u0026#39;PB\u0026#39;] integer, remainder, level = strofsize(size, 0, 0) if level + 1 \u0026gt; len(units): level = -1 return (\u0026#39;{}.{:\u0026gt;03d} {}\u0026#39;.format(integer, remainder, units[level])) # 发送钉钉通知 def sendDingMessage(message): # 构建通知内容 fileSize = getFileSize(int(message[\u0026#39;buildFileSize\u0026#39;])) buildUpdated = message[\u0026#39;buildUpdated\u0026#39;] buildUpdateDescription = message[\u0026#39;buildUpdateDescription\u0026#39;] buildBuildVersion = message[\u0026#39;buildBuildVersion\u0026#39;] buildVersion = message[\u0026#39;buildVersion\u0026#39;] buildKey = message[\u0026#39;buildKey\u0026#39;] buildQRCodeURL = message[\u0026#39;buildQRCodeURL\u0026#39;] text = [] text.append(\u0026#39;\\n\\n### IOS构建成功,已上传蒲公英\u0026#39;) text.append(\u0026#39;\\n\\n**构建应用**:\\n\\nXXXX\u0026#39;) text.append(f\u0026#39;\\n\\n**构建时间**:\\n\\n{buildUpdated}\u0026#39;) text.append(f\u0026#39;\\n\\n**构建描述**:\\n\\n{buildUpdateDescription}\u0026#39;) text.append(f\u0026#39;\\n\\n**蒲公英版本号**:\\n\\nbuild{buildBuildVersion}\u0026#39;) text.append(f\u0026#39;\\n\\n**IOS包大小**:\\n\\n{fileSize}\u0026#39;) text.append(f\u0026#39;\\n\\n**IOS版本号**:\\n\\n{buildVersion}\u0026#39;) text.append(f\u0026#39;\\n\\n**Git分支**:\\n\\n{getGitBranch()}\u0026#39;) text.append(f\u0026#39;\\n\\n**下载地址**:\\n\\nhttps://www.pgyer.com/{buildKey}\u0026#39;) text.append(f\u0026#39;\\n\\n**安装密码**:\\n\\ncarzone123\u0026#39;) text.append(f\u0026#39;\\n\\n![]({buildQRCodeURL})\u0026#39;) context = \u0026#39;\u0026#39;.join(text) # 发送钉钉通知 webhook = \u0026#39;https://oapi.dingtalk.com/robot/send?access_token\u0026#39; \\ \u0026#39;=1c7d9f9d880ca4ca9fxxxxxxxxxxxxxxxxxxxxxxxxxxxx \u0026#39; headers = {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;} data = { \u0026#39;msgtype\u0026#39;: \u0026#39;markdown\u0026#39;, \u0026#39;markdown\u0026#39;: { \u0026#34;title\u0026#34;: \u0026#39;蒲公英机器人\u0026#39;, \u0026#39;text\u0026#39;: context }, \u0026#39;at\u0026#39;: { \u0026#39;atMobiles\u0026#39;: [], \u0026#39;isAtAll\u0026#39;: False } } x = requests.post(url=webhook, data=json.dumps(data), headers=headers) if x.json()[\u0026#34;errcode\u0026#34;] == 0: print(\u0026#34;\\n*************** 钉钉消息已发送 ***************\u0026#34;) # Press the green button in the gutter to run the script. if __name__ == \u0026#39;__main__\u0026#39;: # 构建应用 fastlane(sys.argv[1]) # 上传蒲公英 uploadResult = uploadPyger(sys.argv[1]) # 发送钉钉通知 sendDingMessage(uploadResult[\u0026#39;data\u0026#39;]) # See PyCharm help at https://www.jetbrains.com/help/pycharm/ 使用pyinstaller 打出脚本，重命名PgyerBuild FastLane配置模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # This file contains the fastlane.tools configuration # You can find the documentation at https://docs.fastlane.tools # # For a list of all available actions, check out # # https://docs.fastlane.tools/actions # # For a list of all available plugins, check out # # https://docs.fastlane.tools/plugins/available-plugins # # Uncomment the line if you want fastlane to automatically update itself # update_fastlane default_platform(:ios) platform :ios do desc \u0026#34;build project\u0026#34; lane :buildDebug do #配置工程基本信息 update_app_identifier( xcodeproj: \u0026#34;TooWellMerchant.xcodeproj\u0026#34;, # Optional path to xcodeproj, will use the first .xcodeproj if not set plist_path: \u0026#34;TooWellMerchant/Info.plist\u0026#34;, # Path to info plist file, relative to xcodeproj app_identifier: \u0026#34;com.xxxxxx.xxxxxx\u0026#34; # The App Identifier ) #配置签名以及证书 automatic_code_signing( path: \u0026#34;TooWellMerchant.xcodeproj\u0026#34;, #启用自动签名 use_automatic_signing: true, code_sign_identity: \u0026#34;Apple Development\u0026#34;, #根据证书拿到团队ID或者直接去苹果开发者官方查阅 team_id:\u0026#34;K4T4XXXXXX\u0026#34;, ) #配置生成包的类型以及发布渠道 gym(scheme: \u0026#34;TooWellMerchant\u0026#34;, workspace: \u0026#34;TooWellMerchant.xcworkspace\u0026#34;, configuration: \u0026#34;Debug\u0026#34;, clean: true, output_name:\u0026#34;TooWellMerchant.ipa\u0026#34;, #只打Arm64，缩小包体积 xcargs:\u0026#34;ARCHS=\u0026#39;arm64\u0026#39;\u0026#34;, #IOS 9适配 export_xcargs:\u0026#34;-allowProvisioningUpdates\u0026#34;, export_method: \u0026#34;development\u0026#34; # app-store, ad-hoc, package, enterprise, development, developer-id ) end lane :buildRelease do update_app_identifier( xcodeproj: \u0026#34;TooWellMerchant.xcodeproj\u0026#34;, # Optional path to xcodeproj, will use the first .xcodeproj if not set plist_path: \u0026#34;TooWellMerchant/Info.plist\u0026#34;, # Path to info plist file, relative to xcodeproj app_identifier: \u0026#34;com.xxxxxx.xxxxxx\u0026#34; # The App Identifier ) automatic_code_signing( path: \u0026#34;TooWellMerchant.xcodeproj\u0026#34;, use_automatic_signing: true, code_sign_identity: \u0026#34;Apple Development\u0026#34;, team_id:\u0026#34;K4T4XXXXXX\u0026#34;, ) gym(scheme: \u0026#34;TooWellMerchant\u0026#34;, workspace: \u0026#34;TooWellMerchant.xcworkspace\u0026#34;, configuration: \u0026#34;Release\u0026#34;, clean: true, output_name:\u0026#34;TooWellMerchant.ipa\u0026#34;, #只打Arm64，缩小包体积 xcargs:\u0026#34;ARCHS=\u0026#39;arm64\u0026#39;\u0026#34;, #IOS 9适配 export_xcargs:\u0026#34;-allowProvisioningUpdates\u0026#34;, export_method: \u0026#34;development\u0026#34; # app-store, ad-hoc, package, enterprise, development, developer-id ) end end ","date":"2023-04-07T10:07:54+08:00","permalink":"https://rmondjone.github.io/posts/devops/ios_pgyer/","title":"IOS 一键打包上传蒲公英脚本"},{"content":"一、业务背景 日常开发中，我们会用到YApi这个工具，YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台，可以进行接口定义以及接口模拟的一些操作。\n有关更多的YApi使用教程，可以参考YApi官网，这里就不再过多的赘述。\n本插件是一个基于YApi开源接口之上的一个编码工具插件，主要用于接口定义实体代码的快速生成，只要在插件设置选项中进行简单的配置，即可一键快速生成多种你想要的语言接口定义实体代码。\n目前支持生成的语言有：Kotlin、Java、TypeScript、Dart、Swift、Objective-C、Go、C++\n二、插件下载以及配置 下载 直接插件市场搜索Yapi QuickType进行下载\n插件配置 YApi根路径填入自建的地址 配置你需要的项目的Id、Token 这些都可以在YApi项目配置里找到，找到复制填入即可，项目名称可以随意填写。 重启IDE使配置生效 三、插件的使用以及效果 （1）插件的使用也非常简单，只需要在你想要生成代码的目录右键即可 (2) JSON代码生成插件：粘贴复制的JSON字符串、输入生成的实体名称、选择想要生成的语言点击OK生成代码 (3) YApi代码生成插件：选择你配置的项目的对应接口和想要生成的语言 #####（4）生成代码效果 注：IDE内部版本号低于203的使用FIX-IU171版本\n如果请求QuickTypeNode服务失败，请配置以下host\n1 172.67.196.35 quicktype.guohanlin.com 如果配置Host还是不行，你可以尝试本地搭建QuickTypeNode服务，然后服务地址配置到插件中即可 QuickTypeNode\n","date":"2023-04-07T10:04:45+08:00","permalink":"https://rmondjone.github.io/posts/jetbrains/yapi_quick_type/","title":"YapiQuickType插件使用说明"},{"content":"一、背景 我们在写组件库的时候，都想有一个自动化的工具生成组件库文档，网上也有需要这种类似的库。最终对比下来还是docsify比较简单，而且可定制化、可扩展多一点。\ndocsify不受项目使用语言限制，只需项目中使用markdown来书写组件库文档即可通过docsify快速的生成组件库文档。\n二、Docsify的使用 全局安装环境 1 npm i docsify-cli -g 项目中初始化 1 docsify init ./docs 执行完毕，生成 docs 目录。里面有3个文件：\n.nojekyll：让gitHub不忽略掉以 _ 打头的文件 index.html：整个网站的核心文件 README.md：默认页面 Docsify的配置 主页的设置 如果不想使用README.md作为主页，这可以修改index.html手动指定homepage设置主页\n1 2 3 4 window.$docsify = { homepage:\u0026#39;home.md\u0026#39;, ... } 侧边栏的设置 如果需要侧边栏导航，则放开loadSidebar属性，并指定相应的md侧边栏文件\n1 2 3 4 5 window.$docsify = { loadSidebar: \u0026#39;sidebar.md\u0026#39;, subMaxLevel: 3, //子菜单最大层级 ... } sidebar.md里的示例\n1 2 3 4 5 6 7 * [首页](/) * APCommonButton按钮组件 * [APCommonButton](components/button/buttons.md) * APCommonPopup弹窗组件 * [APCommonPopup](components/popup/popup.md) * [APCommonPopup1](components/popup/popup1.md) 设置搜索 如果需求全局搜索，只需要配置search属性即可\n1 2 3 4 window.$docsify = { search: \u0026#39;auto\u0026#39;, auto2top: true, } Docsify文档的生成 设置完成之后，只需输入以下命令即可进行文档预览\n1 docsify serve docs Docsify更多配置 请参考以下链接: https://docsify.js.org/#/configuration\n三、结合Docker自动化输出文档 Dockerfile 在项目根目录新建Dockerfile,代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #下载Node环境 FROM node:10.12.0-alpine #作者信息 MAINTAINER guohanlin #配置linux服务器需要的环境 RUN apk add --no-cache git bash openssh-client tzdata #配置环境 ENV TZ Asia/Shanghai #指定到工作目录 WORKDIR /usr/src/app/ #Docker镜像环境执行npm RUN npm install -g docsify-cli #拷贝代码到Docker镜像工作目录 COPY . . #服务透出端口 EXPOSE 3000 #开始运行服务 CMD docsify serve docs 服务器生成Docker镜像并运行服务 生成Docker镜像 1 docker build . -t xxxxxx(你要生成的镜像名称) 运行Docker镜像，对外提供文档服务 1 docker run --name commmon_docs -p 9000:3000 xxxxxx(前面生成的镜像名称) ","date":"2023-04-07T10:02:39+08:00","permalink":"https://rmondjone.github.io/posts/other/docsify_kit/","title":"使用Docsify生成组件库文档"},{"content":"一、背景 在日常开发中，如果需要抓包，过程很繁琐，于是我就想着这一步能不能简化。主要遇到如下几个痛点：\n每次设置WIFI代理都得去手机设置中心—无线网—设置WIFI代理 每次设置完WIFI代理不想用了，还得去手机设置中心去清理WIFI代理 设置完WIFI代理之后，手机无法正常访问网站，比如测试经常跑过来问我为什么蒲公英包下载不了，结果排查半天是无线网设置了代理 二、方案预研 一开始网上找了一些方案，主要找到了以下几种方案\nADB设置系统WIFI代理 这个方案弊端很明显，需要手机连着电脑，而且每次设置完代理之后，想要清除代理还得重启手机。\n代码反射设置系统WIFI代理 这个方案也不行，因为貌似Android5.0之后就没有用，然后还得不停的跟着Android系统版本进行适配\n三、方案定稿 综上所述，貌似没有一个完美的方案可以解决这个问题。难道这个问题真的无解了？我们只能默默的手动去老老实实的手动设置？ 功夫不负有心人，只要你想，没有不可能。观察我们项目的代码，我发现所有的网络接口请求都是使用OkHttp去请求，思路一下打开。是不是OkHttp有提供方法出来给我们设置代理呢，网上一搜，果然一堆。\n四、实现效果 我在Dokit工具中加了一个小工具，我们就可以快乐的使用这个小工具快速的进行抓包了。而且不会设置手机自身的WIFI代理，不影响手机正常的访问网站。 五、核心代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class NetWorkProxyKit : AbstractKit() { override val icon: Int get() = R.drawable.ic_acting override val name: Int get() = R.string.tools_proxy override fun onAppInit(context: Context?) { } @RequiresApi(Build.VERSION_CODES.LOLLIPOP) @SuppressLint(\u0026#34;SetTextI18n\u0026#34;) override fun onClickWithReturn(activity: Activity): Boolean { val view = LayoutInflater.from(activity).inflate(R.layout.layout_proxy_setting, null) val hostEdit = view.proxy_host val portEdit = view.proxy_port val proxyHistoryGroup = view.proxy_history_group val emptyView = view.proxy_history_empty //设置历史代理设置监听 proxyHistoryGroup.setOnCheckedChangeListener { group, checkedId -\u0026gt; val radioButton = group.findViewById\u0026lt;RadioButton\u0026gt;(checkedId) val ip = radioButton.text.toString() hostEdit.setText(ip.split(\u0026#34;:\u0026#34;)[0]) portEdit.setText(ip.split(\u0026#34;:\u0026#34;)[1]) } //回显上次设置的代理 val host = ACache.get(activity).getAsString(\u0026#34;proxy_host\u0026#34;) val port = ACache.get(activity).getAsString(\u0026#34;proxy_port\u0026#34;) if (!TextUtils.isEmpty(host) \u0026amp;\u0026amp; !TextUtils.isEmpty(port)) { hostEdit.setText(host) portEdit.setText(port) } //回显历史设置 val proxyList: JSONArray = ACache.get(activity).getAsJSONArray(\u0026#34;proxy_list\u0026#34;) ?: JSONArray() if (proxyList.length() \u0026gt; 0) { emptyView.visibility = View.GONE proxyHistoryGroup.visibility = View.VISIBLE var index = 0 val keys = arrayListOf\u0026lt;String\u0026gt;() var selectId = -1 //动态构建选中项 for (i in (proxyList.length() - 1) downTo 0) { //只展示最近5条 if (index == 5) break val proxy: JSONObject = proxyList[i] as JSONObject val proxyHost = proxy[\u0026#34;proxy_host\u0026#34;] val proxyPort = proxy[\u0026#34;proxy_port\u0026#34;] val ip = \u0026#34;${proxyHost}:${proxyPort}\u0026#34; if (!keys.contains(ip)) { val radioButton = RadioButton(activity) radioButton.text = ip radioButton.id = ThreadLocalRandom.current().nextInt() if (proxyHost.equals(host)) { selectId = radioButton.id } proxyHistoryGroup.addView(radioButton) keys.add(ip) index++ } } //设置选中项 if (selectId != -1) { proxyHistoryGroup.check(selectId) } } else { emptyView.visibility = View.VISIBLE proxyHistoryGroup.visibility = View.GONE } val dialog = AlertDialog.Builder(activity) .setTitle(\u0026#34;设置网络代理\u0026#34;) .setView(view) .setNegativeButton(\u0026#34;清空代理\u0026#34;) { _, _ -\u0026gt; ACache.get(activity).put(\u0026#34;proxy_host\u0026#34;, \u0026#34;\u0026#34;) ACache.get(activity).put(\u0026#34;proxy_port\u0026#34;, \u0026#34;\u0026#34;) ToastUtil.shortToast(activity, \u0026#34;1s后将退出应用，再次重启生效！\u0026#34;) Handler(Looper.getMainLooper()).postDelayed({ exitProcess(0) }, 1500) } .setPositiveButton(\u0026#34;设置代理\u0026#34;) { _, _ -\u0026gt; ACache.get(activity).put(\u0026#34;proxy_host\u0026#34;, hostEdit.text.toString()) ACache.get(activity).put(\u0026#34;proxy_port\u0026#34;, portEdit.text.toString()) ToastUtil.shortToast(activity, \u0026#34;1s后将退出应用，再次重启生效！\u0026#34;) saveProxyList(activity, hostEdit.text.toString(), portEdit.text.toString()) Handler(Looper.getMainLooper()).postDelayed({ exitProcess(0) }, 1500) }.create() dialog.show() return super.onClickWithReturn(activity) } /** * 注释：保存历史代理设置 * 时间：2021/12/21 0021 17:34 */ private fun saveProxyList(context: Context?, host: String, port: String) { val proxyList = ACache.get(context).getAsJSONArray(\u0026#34;proxy_list\u0026#34;) ?: JSONArray() val params = mapOf(Pair(\u0026#34;proxy_host\u0026#34;, host), Pair(\u0026#34;proxy_port\u0026#34;, port)) proxyList.put(JSONObject(params)) ACache.get(context).put(\u0026#34;proxy_list\u0026#34;, proxyList) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 OkHttpClient.Builder mOkHttpClient = new OkHttpClient.Builder() //设置请求读写的超时时间 .connectTimeout(15, TimeUnit.SECONDS) .writeTimeout(15, TimeUnit.SECONDS) .readTimeout(15, TimeUnit.SECONDS) .callTimeout(15, TimeUnit.SECONDS) .cache(cache) .addInterceptor(new HeaderInterceptor()) .addInterceptor(interceptor); //设置网络抓包代理 if (BuildConfig.DEBUG \u0026amp;\u0026amp; !TextUtils.isEmpty(ACache.get(context).getAsString(\u0026#34;proxy_host\u0026#34;))) { val host = ACache.get(context).getAsString(\u0026#34;proxy_host\u0026#34;) val port = ACache.get(context).getAsString(\u0026#34;proxy_port\u0026#34;) config.setProxy(Proxy(Proxy.Type.HTTP, InetSocketAddress(host, port.toInt()))) } //网络代理 if (config != null \u0026amp;\u0026amp; config.getProxy() != null) { mOkHttpClient.proxy(config.getProxy()); } H5代理设置\nWebView需要导入最新的WebKit内核完成这个事情，支持Android9以后的系统\n1 implementation \u0026#39;androidx.webkit:webkit:1.4.0\u0026#39; 1 2 3 4 5 6 7 8 9 10 String host = ACache.get(getActivity()).getAsString(\u0026#34;proxy_host\u0026#34;); String port = ACache.get(getActivity()).getAsString(\u0026#34;proxy_port\u0026#34;); if (WebViewFeature.isFeatureSupported(WebViewFeature.PROXY_OVERRIDE) \u0026amp;\u0026amp; !TextUtils.isEmpty(host)) { ProxyConfig proxyConfig = new ProxyConfig.Builder() .addProxyRule(host + \u0026#34;:\u0026#34; + port) .addDirect().build(); ProxyController.getInstance().setProxyOverride(proxyConfig, command -\u0026gt; { //do nothing }, () -\u0026gt; Log.e(TAG, \u0026#34;WebView代理改变\u0026#34;)); } ","date":"2023-04-07T09:55:49+08:00","permalink":"https://rmondjone.github.io/posts/mobile/network_proxy_tool/","title":"Android应用内网络抓包快捷工具开发"},{"content":"一、Yapi是什么？ YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。\n二、Yapi的快速搭建 1、Docker创建mongoDB的虚拟磁盘 1 docker volume create mongo-data 2、拉取mongoDB镜像并且创建容器 1 docker pull mongo:latest 1 2 3 4 5 6 7 8 9 10 docker run -d \\ --name mongodb \\ --restart always \\ --net=yapi \\ -p 27017:27017 \\ -v mongo-data:/data/db \\ -e MONGO_INITDB_DATABASE=yapi \\ -e MONGO_INITDB_ROOT_USERNAME=yapipro \\ -e MONGO_INITDB_ROOT_PASSWORD=yapipro1024 \\ mongo 3、进入MongoDB容器，初始化表 1 docker exec -it mongodb mongosh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use admin; db.auth(\u0026#34;yapipro\u0026#34;, \u0026#34;yapipro1024\u0026#34;); # 创建 yapi 数据库 use yapi; # 创建给 yapi 使用的账号和密码，限制权限 db.createUser({ user: \u0026#39;yapi\u0026#39;, pwd: \u0026#39;yapi123456\u0026#39;, roles: [ { role: \u0026#34;dbAdmin\u0026#34;, db: \u0026#34;yapi\u0026#34; }, { role: \u0026#34;readWrite\u0026#34;, db: \u0026#34;yapi\u0026#34; } ] }); # 退出 Mongo Cli exit # 退出容器 exit 4、宿主机创建Yapi配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;port\u0026#34;: \u0026#34;3000\u0026#34;, \u0026#34;adminAccount\u0026#34;: \u0026#34;xxxxxx@gmail.com\u0026#34;, \u0026#34;timeout\u0026#34;:120000, \u0026#34;db\u0026#34;: { \u0026#34;servername\u0026#34;: \u0026#34;mongo\u0026#34;, \u0026#34;DATABASE\u0026#34;: \u0026#34;yapi\u0026#34;, \u0026#34;port\u0026#34;: 27017, \u0026#34;user\u0026#34;: \u0026#34;yapi\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;yapi123456\u0026#34;, \u0026#34;authSource\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;mail\u0026#34;: { \u0026#34;enable\u0026#34;: true, \u0026#34;host\u0026#34;: \u0026#34;smtp.gmail.com\u0026#34;, \u0026#34;port\u0026#34;: 465, \u0026#34;from\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;auth\u0026#34;: { \u0026#34;user\u0026#34;: \u0026#34;xxxxxx@gmail.com\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;xxx\u0026#34; } } } 5、拉取Yapi镜像并创建容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 docker pull yapipro/yapi:latest # 初始化数据库表 docker run -d --rm \\ --name yapi-init \\ --link mongodb:mongo \\ --net=yapi \\ -v $PWD/config.json:/yapi/config.json \\ yapipro/yapi \\ server/install.js # 初始化管理员账号在上面的 config.json 配置中 hexiaohei1024@gmail.com，初始密码是 yapi.pro，可以登录后进入个人中心修改 docker run -d \\ --name yapi \\ --link mongodb:mongo \\ --restart always \\ --net=yapi \\ -p 3000:3000 \\ -v $PWD/config.json:/yapi/config.json \\ yapipro/yapi \\ server/app.js # 在服务器上验证 yapi 启动是否成功 curl localhost:3000 三、Yapi的访问地址 直接访问宿主机的3000端口即可，例如 http://localhost:3000\n","date":"2023-04-07T09:53:15+08:00","permalink":"https://rmondjone.github.io/posts/other/yapi/","title":"Yapi Pro的搭建"},{"content":"一、前言介绍 Hugo是一个个人博客静态框架，相比于Hexo更加轻量生成更加快速。结合GitHub.io可以快速的搭建生成属于自己的博客，并且有丰富的主题和插件支持。\n二、搭建过程 这里主要阐述Mac上搭建的过程，Window的过程基本类似，唯一的不同就是Hugo本地环境的搭建。这个官网基本都有教程可以自己去官网查看。\n1、Hugo本地环境的搭建 使用brew命令直接按照官网最新的Hugo版本\n1 brew install hugo 运行以下命令，有版本输出则本地环境搭建完毕\n1 2 3 4 hugo version guohanlin@guohanlindeMacBook-Pro RmondJone.github.io % hugo version hugo v0.89.4+extended darwin/amd64 BuildDate=unknown 2、GitHub创建io仓库并使用Hugo Action 创建IO仓库 必须按照以下格式创建：.github.io，userName就是你的GitHub名称\n创建Hugo Action 访问你刚刚创建的仓库 Settings \u0026gt; Pages. 你将会看到以下选项： 切换至GitHub Action: 有默认的Hugo模板，选中启用即可,会自动生成以下文件。如果你没有看到，也可以手动创建。\n.github/workflows/hugo.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.111.3 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass Embedded run: sudo snap install dart-sass-embedded - name: Checkout uses: actions/checkout@v3 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v3 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: # For maximum backward compatibility with Hugo modules HUGO_ENVIRONMENT: production HUGO_ENV: production run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v2 3、拉去Git仓库本地Hugo调试 创建默认站点 进入到Git工程目录，执行以下命令\n1 hugo new site . 执行完命令之后会生成以下目录结构:\n1 2 3 4 5 6 7 8 9 10 11 . ├── archetypes │ └── default.md ├── assets ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 设置想要的主题 Hugo的主题有很多，可以去官网的主题目录挑选合适的主题。我这里使用的主题是hugo-papermod,以这个主题为例。首先进入themes目录，然后git clone下来。\n1 2 3 cd themes git clone git@github.com:adityatelange/hugo-PaperMod.git 然后在config.yaml里theme: 'hugo-PaperMod'配置默认主题即可。config.toml我使用不习惯，所以这里我直接改成的yaml写法，直接更改后缀即可，这里直接展示我的yaml配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #基础配置 baseURL: \u0026#39;http://rmondjone.github.io\u0026#39; languageCode: \u0026#39;zh-CN\u0026#39; title: \u0026#39;郭翰林的博客\u0026#39; theme: \u0026#39;hugo-PaperMod\u0026#39; enableInlineShortcodes: true enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false enableEmoji: true #配置菜单 menu: main: - name: 🔍 搜索 url: search/ weight: 10 - name: 分类 url: tags/ weight: 10 - name: 关于我 url: about/ weight: 10 - name: 首页 url: / weight: 10 #主题配置参数 params: defaultTheme: auto homeInfoParams: Title: \u0026#34;技能树\u0026#34; Content: \u0026gt; XXXXXXXXXX你要显示内容 socialIcons: - name: Github url: \u0026#34;https://github.com/RmondJone\u0026#34; - name: Email url: about/ 生成文章 生成文章主要就是使用hugo new xxxx.md这个命令去生成文章即可，执行完命令之后，会自动生成md文件在content目录。如果使用hugo new post/xxx.md ，则会在content目录下多生成一个post目录。以此类推。\n关于Markdown的图片引用 markdown中使用图片引用，需要在static目录下新建一个images文件夹，当然目录名称随便你取，我这里只是举个例子。然后把图片放到images文件夹里。在markdown里像如下写法引用：\n1 ![](/images/weixin.jpg) 本地调试 直接使用命令hugo server -D即可，执行完命令之后，会有以下输出，直接点击链接预览即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 guohanlin@guohanlindePro RmondJone.github.io % hugo server Start building sites … hugo v0.111.3+extended darwin/amd64 BuildDate=unknown | EN -------------------+----- Pages | 17 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 4 Sitemaps | 1 Cleaned | 0 Built in 30 ms Watching for changes in /Users/guohanlin/Documents/GitHub/RmondJone.github.io/{archetypes,content,static,themes} Watching for config changes in /Users/guohanlin/Documents/GitHub/RmondJone.github.io/config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 远程部署 本地调试如果没有问题，直接使用命令hugo -D生成静态文件即可。然后提交到git上，如果本地不执行命令也没有关系，前面配置的git action会帮你自动执行一遍。然后通过https://\u0026lt;userName\u0026gt;.github.io即可访问你的博客\n","date":"2023-04-06T20:10:10+08:00","permalink":"https://rmondjone.github.io/posts/other/hugo_github/","title":"Hugo+Github.io搭建自己的博客"},{"content":"一、使用场景 某些场景，需要监听用户的锁屏事件，再次打开锁屏之后显示自己的锁屏页面，这个锁屏页面有可能在做一些计时等操作，类似于Keep的锁屏跑步计时功能。\n二、代码实现 废话不多，直接上代码，我们假设有2个Activity，一个A，一个B。在A中监听用户的锁屏，B是我们自定义的锁屏页面。\n页面A的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * @author 郭翰林 * @date 2020/8/17 0017 11:31 * 注释: */ public class LoadActivity extends AppCompatActivity { Button lockNoticeButton; private ScreenListener listener; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { //设置导航栏透明 StatusBarHelper.fitsSystemWindows(this); StatusBarHelper.translucent(this); super.onCreate(savedInstanceState); //请求存储权限 PermissionUtils.applicationPermissions(this, new PermissionUtils.PermissionListener() { @Override public void onSuccess(Context context) { } @Override public void onFailed(Context context) { } //在锁屏页面显示 if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O_MR1) { setShowWhenLocked(true); } else { getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD); } setContentView(R.layout.activity_load); //设置锁屏监听 listener = new ScreenListener(this); listener.register(new ScreenListener.ScreenStateListener() { @Override public void onScreenOn(Context context) { } @Override public void onScreenOff(Context context) { if (context instanceof Activity) { MainActivity.gotoMe(((Activity) context)); finish(); } } @Override public void onUserPresent(Context context) { } }); } @Override protected void onDestroy() { super.onDestroy(); if (listener != null) { listener.unregister(); } } 这边页面A页必须要设置锁屏页显示，否则无法正常调整，另外跳转B时需要添加Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS标记\n1 2 3 4 5 6 7 8 9 10 11 //在锁屏页面显示 if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O_MR1) { setShowWhenLocked(true); } else { getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD); } //跳转添加标记 Intent intent = new Intent(activity, MainActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); activity.startActivity(intent); 页面B的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package com.rmondjone.lockscreen; import androidx.appcompat.app.AppCompatActivity; import android.app.Activity; import android.app.WallpaperManager; import android.content.Context; import android.content.Intent; import android.graphics.Bitmap; import android.graphics.drawable.BitmapDrawable; import android.graphics.drawable.Drawable; import android.os.Build; import android.os.Bundle; import android.view.Gravity; import android.view.View; import android.view.ViewGroup; import android.view.Window; import android.view.WindowManager; import android.widget.FrameLayout; import android.widget.ImageView; import android.widget.LinearLayout; import com.yanzhenjie.permission.Permission; public class MainActivity extends AppCompatActivity { private SuperSwipeLayout swipLayout; private ImageView mImageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //设置导航栏透明 StatusBarHelper.fitsSystemWindows(this); StatusBarHelper.translucent(this); //在锁屏页面显示 if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O_MR1) { setShowWhenLocked(true); } else { getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED|WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD); } //开启侧滑退出 openSlidingExitToWindow(getWindow(), false); setContentView(R.layout.activity_main); mImageView=findViewById(R.id.img_back); mImageView.setImageBitmap(getWallPaper()); } @Override public void onBackPressed() { } /** * 注释：跳转 * 时间：2020/8/17 0017 11:37 * 作者：郭翰林 * * @param activity */ public static void gotoMe(Activity activity) { Intent intent = new Intent(activity, MainActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); activity.startActivity(intent); } /** * 注释：打开侧滑退出 * 时间：2020/8/17 0017 11:36 * 作者：郭翰林 * * @param window * @param addReplaceStatus */ public void openSlidingExitToWindow(Window window, boolean addReplaceStatus) { ViewGroup decorView = (ViewGroup) window.getDecorView(); View childContair = decorView.getChildAt(0); decorView.removeView(childContair); swipLayout = new SuperSwipeLayout(childContair, window); LinearLayout ll_contair = new LinearLayout(childContair.getContext()); ll_contair.setOrientation(LinearLayout.VERTICAL); if (addReplaceStatus) { swipLayout.addView(getStatusBarView(swipLayout.getContext()), 0); } ll_contair.addView(swipLayout, new LinearLayout.LayoutParams(-1, -1)); decorView.addView(ll_contair, new FrameLayout.LayoutParams(-1, -1)); //开启侧滑 swipLayout.setSwipe(true); } private View getStatusBarView(Context context) { View statusBarView = new View(context); statusBarView.setBackgroundResource(android.R.color.transparent); ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams(-1, AppUtils.getStatusBarHeight(context)); statusBarView.setLayoutParams(lp); return statusBarView; } /** * 注释：获取系统壁纸 * 时间：2020/8/17 0017 10:18 * 作者：郭翰林 * * @return */ public Bitmap getWallPaper() { WallpaperManager wallpaperManager = WallpaperManager .getInstance(MainActivity.this); // 获取当前壁纸 Drawable wallpaperDrawable = wallpaperManager.getDrawable(); Bitmap bm = ((BitmapDrawable) wallpaperDrawable).getBitmap(); int heightPixels = getResources().getDisplayMetrics().heightPixels; int widthPixels = getResources().getDisplayMetrics().widthPixels; int with = bm.getHeight() * widthPixels / heightPixels \u0026gt; bm.getWidth() ? bm.getWidth() : bm.getHeight() * widthPixels / heightPixels; Bitmap pbm = Bitmap.createBitmap(bm, 0, 0, with, bm.getHeight()); // 设置 背景 return pbm; } } 这里有几个点，需要详细描述，一个是页面B需要设置背景透明的主题，要不然侧滑时看不到页面A。\n1 \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:theme=\u0026#34;@style/TransparentTheme\u0026#34;/\u0026gt; 1 2 3 4 5 6 \u0026lt;style name=\u0026#34;TransparentTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.Light.NoActionBar\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowBackground\u0026#34;\u0026gt;@android:color/transparent\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:colorBackgroundCacheHint\u0026#34;\u0026gt;@null\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowIsTranslucent\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowAnimationStyle\u0026#34;\u0026gt;@android:style/Animation\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 我们这边是使用了桌面主题壁纸作为页面B的背景，当然这边你也可以自定义背景，这个都无所谓，但是如果你用了桌面的壁纸就需要注意权限的申请，这边需要用到存储权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 注释：获取系统壁纸 * 时间：2020/8/17 0017 10:18 * 作者：郭翰林 * * @return */ public Bitmap getWallPaper() { WallpaperManager wallpaperManager = WallpaperManager .getInstance(MainActivity.this); // 获取当前壁纸 Drawable wallpaperDrawable = wallpaperManager.getDrawable(); Bitmap bm = ((BitmapDrawable) wallpaperDrawable).getBitmap(); int heightPixels = getResources().getDisplayMetrics().heightPixels; int widthPixels = getResources().getDisplayMetrics().widthPixels; int with = bm.getHeight() * widthPixels / heightPixels \u0026gt; bm.getWidth() ? bm.getWidth() : bm.getHeight() * widthPixels / heightPixels; Bitmap pbm = Bitmap.createBitmap(bm, 0, 0, with, bm.getHeight()); // 设置 背景 return pbm; } mImageView=findViewById(R.id.img_back); mImageView.setImageBitmap(getWallPaper()); 另一个就是返回键的屏蔽。\n1 2 3 4 @Override public void onBackPressed() { } 三、Demo地址\n欢迎Star: https://github.com/RmondJone/LockScreenDemo ","date":"2023-04-06T16:16:07+08:00","permalink":"https://rmondjone.github.io/posts/mobile/custom_lock_screen/","title":"Android自定义锁屏"}]